function protStructComb  = runPosFunc2Protocols(pStructCombPar, funcHand, pStructCell)

%% function protStructComb  = runPosFunc2Protocols(pStructCombPar, funcHand, pStruct)
%
% This function uses the function handle and the given protocol structure
% to generate the required stimuli and run them in the new panel
% controller (use tcp connection). This version of the function enables the
% combination of 2 independent protocols. pStruct has to be a cell
% array if given since protocol have slightly different structures.
% The function can handle 4 types of inputs: 
% (0)   no input is given and function will ask for inputs.
% (1)   Cell array of 2 function handles. The function will create a pStruct of
%       the same length and will apply one to each function hadnle.
% (2)   Single function handle. The function will ask for user input for
%       2  pStruct. The same function handle will be applied to all
%       pStruct components.
% (3)   Cell array of function handles and pStruct of same length. The
%       function handles will be applied to the pStruct components in a serial
%       order
% (4)   Single function handle, and pStruct w/ length more than 1. Same 
%       function handle will be applied to all components of pStruct 
% If the length of funcHand and pStruct is not one and not equal the
% function will generate an error.
%
% For now the function requires that within each pStruct the length of stim will be the same. 
% If this is not the case it will cause an error. 
%
% INPUTS
% pStructCombPar -      (optional) structure with the paramter by which to combine the
%                       different pStruct stimuli. Should include following
%                       fields:
%
%   .desiredComb -      logical array of at most N X 2^N-1 (N being length
%                       of PStructCell). Showing all the desired combinations of pStructs.
%                       
%                       i.e. if 3 pStrcuts are given full desiredComb would be 7X3 matrix with
%                       all the possible combinations (excluding [0 0 0]).
%                       if only pairwise combination are desitred for these
%                       pStructs then desiredComb would be [0 1 1; 1 0 1; 1
%                       1 0]. This is mainly to allow for easier
%                       implementation of more than 2 inputs.
%                       default: [1, 0; 0, 1; 1, 1];
%   .timing -           cell array of the same length as desiredComb to
%                       specify the timing difference in secs between the
%                       protocols (first protocol given is the reference.  
%                       timing{ii} should be of a sum(desiredComb(ii, :) -1
%                       X T matrix. Meaning you can have T different time delays that you need to 
%                       specify for each additional protocol you combine (again design for future implementation of more than 2). 
%                       For the case of just 2 protocols the structure
%                       should be empty at the [1, 0] and [0, 1] positions
%                       and a 1xT vecotr for [1,1]. 
%                       Timing is converted into frames by: floor(timing*genFreq)
%                       default: {'', '', 0} - presented without delay
% funcHand -            (optional) {array} function handle to one of the createXXXProtocol functions
%                       if not given 'listCreateProtocolFunctions' is envoked
%
% pStructCell -         (optional) protocol structure cell array that will be fed into the
%                       function above. If not given user will be asked for the necessary inputs
%                       Used cell array and not structure since not all
%                       fields are the same between different protocols.
% 
% The general frequency that will be used both for presentation of the stim
% and for timing delay is the one from the first protocol. 
%
% OUTPUT
% protStructComb -      protocol structure with all the relevant fields from
%                       createProtocol, plus same fields as in
%                       runPosFuncProtocol that are generated by data
%                       acquisition. In addition, the structure also
%                       contains the following fileds:
%   .protocols -        protocols that were used to generate the
%                       combined protocol. Each protocol also contains an added uniStim field, 
%                       which is all the unique stimuli for that protocol. 
%   .funcHands -        Function handles that were used to generate the
%                       protocols.
%   .generalFrequency
%   .intFrames
%   .repeats
%   .gsLevel -          All the above are taken from the first protocol
%                       only and applied on the combination. 
%   .inputParams -      pStructCombPar structure that was given as an
%                       input.
%   .origStim -         Structure with all the unique stimuli combinations. Contains the
%                       following fields for each origStim:
%       .combInds -     1X4 element vector indicating (1) desiredComb index
%                       (2) timing index (3) first protocol stim (indexed by uniStim) (4)
%                       same for second protocol stim. 0 when only one stim is displayed 
%       .matCell
%       .patVecMat -    Same as in regular protocolStruct
%   .randomStimSeq -    random sequnece that was used to generate the actual stim presentation order (including repeats)
%                       protStructComb.stim = protStructComb.origStim(randomStimSeq)
%   .stim -             Structure similar to the regular protocolStruct
%                       stim. Only difference is that indcies are of combInds. 
%

%% initiating parameters

fudgeT = 0.25; % adds to session time to make sure pattern presentation is done

% if pStcutCombPar is not given generate default struct
if nargin < 1
    pStructCombPar.desiredComb = [1, 0; 0, 1; 1, 1];
    pStructCombPar.timing = {'', '', [0]};
end

assert(isfield(pStructCombPar, 'desiredComb'), 'pstructCombPar is missing desiredComb field')
assert(size(pStructCombPar.desiredComb, 1) < 4, 'desiredComb bigger than needed')
combSum = sum(pStructCombPar.desiredComb,2);
assert(prod(combSum) > 0, 'desiredComb has an empty line in it')

assert(isfield(pStructCombPar, 'timing'), 'pstructCombPar is missing timing field')
timLen = cellfun(@(x) size(x, 1), pStructCombPar.timing)';

assert(prod(combSum -1 == timLen) == 1, 'timing field does not correspond to desiredComb' )

% if funcHand is not given generate 2 handles 
if nargin < 2
    for ii=1:2
        funcHand{ii} = listCreateProtocolFunctions;
    end
end

% force funcHand into a cell array structure 
if length(funcHand) == 1
    funcHand = {funcHand, funcHand};
elseif length(funcHand) > 2
    error('function handle array should not be longer than 2') 
end


% Makes sure funcHand and pStruct have the right lengths
if nargin < 3
    pStructCell = cell(1, 2);
       
    for ii=1:2
        fprintf('Please input parameters for protocol %d of type %s \n', ii, func2str(funcHand{ii}))
        pStructCell{ii} = feval(funcHand{ii});
    end
    
end

% all inputs are given. in this case pStrcutCellArray should have length 2
if nargin == 3
    assert(length(pStructCell) == 2, 'When all inputs are given, pStructCelltest =  should have length 2')
    
    for ii=1:2
        fprintf('Please input parameters for protocol %d of type %s \n', ii, func2str(funcHand{ii}))
        pStructCell{ii} = feval(funcHand{ii}, pStructCell{ii});
    end
end


%% Extract unique stimuli from each structure (a bit inefficient since the createProtocol functions generate all the repeats also). 
% When extracting stimuli the interleaving frames are stripped 

protocolStructComb = struct;

for ii=1:2
    tempInds = vertcat(pStructCell{ii}.stim.relInds);
    [uniInds, stimInd, ~] = unique(tempInds, 'rows');
    framesToStrip = pStructCell{ii}.intFrames;
    if ii == 1
        genFreq = pStructCell{ii}.generalFrequency;
        genIntFrames = pStructCell{ii}.intFrames;
        genGsLev = pStructCell{ii}.inputParams.gsLevel;
        fprintf('General frequency is %d Hz \n', genFreq);
        genRepeats = pStructCell{ii}.repeats;
    end
    for jj=1:length(stimInd)
        pStructCell{ii}.uniStim(jj).matCell = pStructCell{ii}.stim(stimInd(jj)).matCell(:,:,framesToStrip+1:end-framesToStrip);
        pStructCell{ii}.uniStim(jj).relInds = uniInds(jj,:);
        pStructCell{ii}.uniStim(jj).length = size(pStructCell{ii}.stim(stimInd(jj)).matCell, 3) - 2*framesToStrip; 
    end
end

protocolStructComb.protocols = pStructCell;
protocolStructComb.funcHands = funcHand;
protocolStructComb.inputParams = pStructCombPar;
protocolStructComb.generalFrequency = genFreq;
protocolStructComb.intFrames = genIntFrames;
protocolStructComb.gsLevel = genGsLev;
protocolStructComb.repeats = genRepeats;

% defining background level so stimuli can be combined (by identifying stim
% over background
if genGsLev == 3
    genBkgdLev = 3;
elseif genGsLev == 4
    genBkgdLev = 7;
else
    error('background levels only defined for gsLevel 3 and 4')
end

% not sure this requirement is necessary
allStimLen = cellfun(@(x) length(unique([x.uniStim.length])), pStructCell, 'uniformoutput', 0);
assert(prod(cellfun(@length, allStimLen)) == 1, 'a certain pStruct has stimuli of different lengths')
% maxStimLen = max([allStimLen{:}]);
% framesToPad = maxStimLen - [allStimLen{:}];

% combining stim from different protocols to one structure
arenaSize = size(pStructCell{1}.stim(1).matCell);
arenaSize = arenaSize(1:2);
fillerMat = ones([arenaSize, genIntFrames]) * genBkgdLev; % mat to pad stim before and after it appears (since it was removed to create uniStim)


counter = 0;
for ii=1:size(pStructCombPar.desiredComb, 1)
    relComb = find(pStructCombPar.desiredComb(ii, :));
    if length(relComb) == 1 % no need to combine
        for jj = 1:length(pStructCell{relComb}.uniStim)
            counter = counter + 1;
            protocolStructComb.origStim(counter).matCell = cat(3, fillerMat, pStructCell{relComb}.uniStim(jj).matCell, fillerMat);
            protocolStructComb.origStim(counter).combInds = [ii, 0, 0, 0]; % inds are for the desired combination and the relevant timing delay (in this case only one stim)
            protocolStructComb.origStim(counter).combInds(relComb+2) = jj; 
        end
    elseif length(relComb) == 2 % combining both protocol in all stimuli combinations
        
        for jj=1:length(pStructCell{1}.uniStim)
            
            tempStim1 = pStructCell{1}.uniStim(jj);
            
            for kk=1:length(pStructCell{2}.uniStim)
                
                tempStim2 = pStructCell{2}.uniStim(kk);
                
                for mm=1:length(pStructCombPar.timing{ii})
                    counter = counter+1;
                    relT = pStructCombPar.timing{ii}(mm);
                    relFrameDelay = floor(relT*genFreq);
            
                    if relFrameDelay < 0 % stim2 will appear right after intFrame frames and stim1 after relFrameDelay more
                        tempDiff = tempStim1.length - relFrameDelay - tempStim2.length;
                        totLen = 2*genIntFrames + tempStim2.length + tempDiff * (tempDiff > 0); % only adds if tempdiff is positive
                        stim2ff = genIntFrames+1;
                        stim1ff = stim2ff - relFrameDelay;
                    else
                        tempDiff = tempStim2.length + relFrameDelay - tempStim1.length;
                        totLen = 2*genIntFrames + tempStim1.length + tempDiff * (tempDiff > 0); % only adds if tempdiff is positive
                        stim1ff = genIntFrames+1;
                        stim2ff = stim1ff + relFrameDelay;
                    end
                    
                    protocolStructComb.origStim(counter).matCell = combine2stim(tempStim1.matCell, tempStim2.matCell, totLen, stim1ff, stim2ff, genBkgdLev);
                    protocolStructComb.origStim(counter).combInds = [ii, mm, jj, kk];
                end
                
            end
            
        end
        
    else
        error('This function can only combine 2 protocols')
    end
end



numOrigStim = length(protocolStructComb.origStim);


for ii=1:numOrigStim
    tempPatVec = convertPatternMatrix(protocolStructComb.origStim(ii).matCell);
    protocolStructComb.origStim(ii).patVecMat = tempPatVec; 
end
fprintf('converted stimuli to serial vectors \n')

randSeq = zeros(1, protocolStructComb.repeats * numOrigStim);

for ii=1:protocolStructComb.repeats
    tInds = numOrigStim * (ii-1) + (1:numOrigStim);
    randSeq(tInds) = randperm(numOrigStim);
end

protocolStructComb.randomStimSeq = randSeq;
protocolStructComb.stim = protocolStructComb.origStim(randSeq);

numStim = length(protocolStructComb.stim);


%% Establish panel host connection and manage log files

% getting last file in the log file directory
logDir = 'F:\Panel Host\Support Files\Log Files';
oldFileSt = dir(fullfile(logDir, '*.tdms'));
[~, oldInd] = max([oldFileSt.datenum]);
if ~isempty(oldInd)
    newestOldFileName = oldFileSt(oldInd).name;
else
    newestOldFileName = [];
end


% Establishing panel host connection 
[~ , res] = system('tasklist /fi "imagename eq Panel Host.exe" /fo table /nh');

while ~strcmpi(res(2:6), 'Panel')
    warnh = warndlg('Panel Host is not open; Open and press OK', 'Panel Host Warning', 'modal');
    uiwait(warnh)
    [~ , res] = system('tasklist /fi "imagename eq Panel Host.exe" /fo table /nh');
end

% initiating TCP
establishtcp = questdlg('Would you like to establish TCP connection?', ...
                        'TCP Comm', 'Yes', 'No', 'No');
switch establishtcp
    case 'Yes'
        init_tcp;
        fprintf('TCP initiated \n')
    case 'No'
        fprintf('Verify TCP is initiated \n')
end


%% Presenting patterns

% Sets arena to mid GS level and switches half off (with the second config
% file
Panel_tcp_com('set_config_id', 3)
Panel_tcp_com('g_level_7')


% generating pattern and posfunc files
statPat = make_vSDpattern_image(protocolStructComb);
statPos = make_vSDposfunction_image(protocolStructComb);
assert(statPat == 0, 'Problem creating pattern files')
assert(statPos == 0, 'Problem creating function files')

% Add waitbar to be able to abort protocol cleanly
wbh = waitbar(0,'1','Name','Presenting Protocol',...
            'CreateCancelBtn',...
            'setappdata(gcbf,''canceling'',1)');
setappdata(wbh,'canceling',0)

% save protocolStruct before experiment starts
timeStamp = datestr(now, 'yyyymmdd_HH-MM');
funcStr = cellfun(@(x) x(7:end-8), cellfun(@func2str, funcHand, 'uniformoutput', 0), 'uniformoutput', 0);
funcStr = [funcStr{:}];
folderName = fullfile(pwd, [funcStr, timeStamp]);
[stat, mess] = mkdir(folderName);
assert(stat==1, 'error creating folder: %s', mess)
save(fullfile(folderName, ['protocolStructComb', timeStamp]), 'protocolStructComb')

Panel_tcp_com('set_config_id', 3)
Panel_tcp_com('set_mode', [4, 0]);
Panel_tcp_com('send_gain_bias', [0 0 0 0]);


figH = figure('position', [1450, 50, 450, 150]);
maxValforFig = 2^(protocolStructComb.gsLevel)-1;
relFreq = protocolStructComb.generalFrequency;

for ii=1:numStim
    
    Panel_tcp_log('start') % to minimize non-recorded time loop iteration begin and end in log commands
    
    Panel_tcp_com('set_pattern_id', ii)
    Panel_tcp_com('set_position', [1 1]);
    Panel_tcp_com('set_posfunc_id', [1,ii]);
    Panel_tcp_com('set_funcx_freq', relFreq);
    stimTime = size(protocolStructComb.stim(ii).patVecMat, 2)/relFreq;
    
    waitbar(ii/numStim, wbh, sprintf('Presenting protocl %d of %d',ii, numStim))
    plotMidFrame(mean(protocolStructComb.stim(ii).matCell,3), maxValforFig)
        
    Panel_tcp_com('start')
    
    pause(stimTime + fudgeT)
    
    Panel_tcp_com('stop')
    fileName = Panel_tcp_log('stop');
    protocolStruct.stim(ii).fileName = tempFileName;
    
    if getappdata(wbh,'canceling')
        break
    end
    
    
end

totStimNum = ii;

delete(wbh)
Panel_tcp_com('set_config_id', 3)
Panel_tcp_com('g_level_7')

%% Cleaning up and assigning files to stimuli

% % getting all the new file names
% fileSt = dir(fullfile(logDir, '*.tdms'));
% if ~isempty(newestOldFileName) % gets rid of old files in the directory
%     oldFilesInd = find(arrayfun(@(x) strcmp(fileSt(x).name, newestOldFileName), 1:length(fileSt)));
%     fileSt = fileSt(oldFilesInd+1:end);
% end
% 
% assert(length(fileSt) == totStimNum, 'Generated TDMS files do not match number of stimuli presented')
% 
% [~, fileNameInd] = sort([fileSt.datenum], 'ascend');
% 
% 
% for ii=1:totStimNum
%     protocolStructComb.stim(ii).fileName = fileSt(fileNameInd(ii)).name;
% end



fileNameCell = arrayfun(@(x) protocolStructComb.stim(x).fileName, 1:numStim, 'uniformoutput', 0)';
copyLogFiletoCurrDir(fileNameCell, folderName) 
save(fullfile(folderName, ['protocolStructComb', timeStamp]), 'protocolStructComb')


protStructComb = consolidateData(folderName);
close(figH)


end


