function varargout = plotStimStructResultsHeatMap(pStruct, sepFigDim, stimLines, cLim)

% function plotStimStructResults(pStruct, sepFigDim, sepColDim)
%
% This function reads the data from protocolStruct.stim and presents it as heatmap
% separated by different figures and colors based on the dimensions given
% (dimensions refers to the relInds component of the stim structure)
% 
% Inputs
% pStruct -         protocolStructure as generated by runPosFuncProtocol. 
% sepFigDim -       1-3 index refering to the dimenstion along which to separate
%                   into figures (1- grating, 2 - masks, 3 - orientation)
% stimLines -       (optional) vector of X positions that will be marked by
%                   vertical lines on the plot. Should be given in secs from trial start 
% cLim -            (optional) 1X2 vector to specifiy heatmap limits (if not given
%                   it is min and max)
%
% OUPUT
% handleSt -        Handles to all figures, axes, anmd images in a
%                   structure

close all
relChannel = 3; %since the first column in the data is timeStamp

sampFreq = 10000;
winSize = 100; % size of window over which membrane potential is averaged

if nargin < 3
    stimLines = [];
end

% determining how to divide each figure (by checking maskPositions)
mPos = pStruct.maskPositions;
if iscell(mPos)
    error('Function does not work for trajectories')
else
    xVals = unique(mPos(:,1));
    numX = length(xVals);
    yVals = unique(mPos(:,2));
    numY = length(yVals);
end

%flipping lr puts the arena lower position low in the subplots
subPlotPos = fliplr(generatePositionCell(0.03, 0.94, 0.12, 0.95, 0.02, 0.05, [numX, numY]));
indsNames = {'Grating', 'Mask', 'Orientation'};
allInds = vertcat(pStruct.stim.relInds);
maxLen = 0; % to be used as length on NaN trials
% filling in missing first values (SHOULD BE ALLOCATED TO A DIFFERENT FUNCTION?) 
for ii=1:length(pStruct.stim)
    if ~isempty(pStruct.stim(ii).data)
        firstTS = pStruct.stim(ii).data{1}(1,1);
    
        if firstTS > 0.2 % sometimes the first timestamp is an exteremly large number; this is an arbitrary threshold
            pStruct.stim(ii).data{1}(1,:) = pStruct.stim(ii).data{1}(1,:) - firstTS;
            firstTS = 0;
        end
        missingSamp = round(firstTS*sampFreq);
        matToAdd = nan(4, missingSamp);
        timeVals = linspace(0, firstTS, missingSamp+1);
        timeVals = timeVals(1:end-1);
        matToAdd(1,:) = timeVals;
        pStruct.stim(ii).data{1} = [matToAdd, pStruct.stim(ii).data{1}];
        if length(pStruct.stim(ii).data{1}) > maxLen
            maxLen = length(pStruct.stim(ii).data{1});
        end
    end
end

% since the 4th dim is mask position which determines subplots
assert(ismember(sepFigDim, 1:3), 'Dimension by which to seperate figures cannot be bigger than 3')

baseKey = [0,0,0];
baseKey(sepFigDim) = 1;


numFigs = length(unique(allInds(:, sepFigDim)));
numCols = length(getStimInds(pStruct, [baseKey, 1])); % checks how many diff stim at one location per figure

axh = zeros(numFigs, numX*numY);

% Choosing colors that will make sense (be able to see progression)
%relCols = repmat(linspace(1, 0, 64), 3, 1)'; % gray scale
relCols = cbrewer('qual', 'Set1', numCols);
%close(gcf)
%offset = 5; % to determine relevant colors
%goodColsInds = round(linspace(1+offset, size(relCols, 1) - offset, numCols)); 

dataInd = false(length(pStruct.stim), 1);
for ii=1:length(pStruct.stim)
    dataInd(ii) = ~isempty(pStruct.stim(ii).data);
end

extractedDat = cell(1, length(pStruct.stim));
for ii=1:length(pStruct.stim)
    if dataInd(ii) % if there is data there
        extractedDat{ii} = pStruct.stim(ii).data{1}(relChannel,:)*10;
    else
        extractedDat{ii} = nan(1,maxLen);
    end
end


% calculating indices for stimLines, if they are given
timeStamp = pStruct.stim(1).data{1}(1,:);
lineInds = [];
for ii=1:length(stimLines)
    tempLInd = find(timeStamp - stimLines(ii) > 0, 1, 'first');
    lineInds = [lineInds, tempLInd/winSize]; % to fit the plots x axis
end

minLen = floor(nanmin(cellfun(@length, extractedDat))/winSize)*winSize;
meanRanges = 1:winSize:(minLen+1);

extractedArray = cellfun(@(x) x(1:minLen), extractedDat, 'uniformoutput', 0);
extractedArray = vertcat(extractedArray{:});
meanResp = nan(size(extractedArray,1), length(meanRanges)-1);

for ii=1:length(meanRanges)-1
    meanResp(:,ii) = nanmean(extractedArray(:,meanRanges(ii):meanRanges(ii+1)-1),2);
end

if nargin < 4
    cLim = [nanmin(meanResp(:)), nanmax(meanResp(:))];
else
    assert(isvector(cLim), 'cLim should be a 2 element vector')
    assert(length(cLim) == 2, 'cLim should be a 2 element vector')
    assert(cLim(1) < cLim(2), 'cLim should specify range (first element smaller')
end

imagesHand = zeros(numFigs, numX*numY); 
load('/Users/gruntmane/Documents/Research/ExpCodeandRes/MatlabFunctions/Data_plotting/fireCmap.mat');
cMap = fireCmap;
%cMap = cbrewer('seq', 'Blues', 64);

figH = zeros(1, numFigs+1);

for ii=1:numFigs
    figH(ii) = figure;
    colormap(cMap)
    set(gcf, 'name', [indsNames{sepFigDim}, num2str(ii)], 'color', 'w')
    handForLegend = zeros(1, numCols);
    for jj=1:(numX*numY)
        relXpos = find(xVals == mPos(jj,1));
        relYpos = find(yVals == mPos(jj,2));
        tempInds = getStimInds(pStruct, [baseKey*ii, jj]); 
        tempMat = meanResp([tempInds.inds], :);
        trNumber = [tempInds.inds];
        axh(ii, jj) = axes('position', subPlotPos{relXpos, relYpos});
        [nr, nc] = size(tempMat);
        %imagesHand(ii, jj) = imagesc(tempMat, cLim); 
        imagesHand(ii, jj) = pcolor([tempMat, nan(nr,1); nan(1, nc+1)]); % pcolor does not present last row and col
        caxis(cLim)
        title(num2str(mPos(jj, :)))
        set(axh(ii, jj), 'ytick', (1:length(trNumber))+0.5, 'yticklabel', arrayfun(@num2str, trNumber, 'uniformoutput', 0))
        % Adding lines
        for stimline = 1:length(lineInds)
            line([lineInds(stimline), lineInds(stimline)], [0.05, size(tempMat, 1)+1], ...
                 'linestyle', '--', 'color', [1,1,1]*0.6, 'linewidth', 2)
        end
        
        % Adding rectangles
        prevVal = 1;
        for kk=1:length(tempInds)
            %plotCol = relCols(goodColsInds(kk), :);
            plotCol = relCols(kk, :);
            addVal = length(tempInds(kk).inds);
            rectangle('position', [0.5, prevVal, size(tempMat,2)-0.5, addVal-0.025], ...
                      'linewidth', 6, 'edgecolor', plotCol)
            lh = line([0.5,0.5], [prevVal,prevVal], 'linewidth', 4, 'color', plotCol);
            handForLegend(kk) = lh;
            prevVal = prevVal+addVal;
        end
        hold off
    end
    
    legend(axh(ii, end), handForLegend, arrayfun(@num2str, 1:numCols, 'uniformoutput', 0))
    
    xxtick = get(axh(ii, 1), 'xtick');
    set(axh(ii, :), 'xtick', xxtick, 'xticklabel', {})
    set(axh(ii, 1:numY:(numX*numY)), 'xtick', xxtick, 'xticklabel', arrayfun(@num2str, xxtick*winSize/sampFreq, 'uniformoutput', 0))
    
    
    % plotting colorbar
    if mod(numX, 2)
        tempPos = subPlotPos{2,1};
        xSt = tempPos(1);
        xWid = tempPos(3);
    else
        tempPos1 = subPlotPos{floor((numX+1)/2), 1};
        tempPos2 = subPlotPos{ceil((numX+1)/2), 1};
        xSt = tempPos1(1) + tempPos1(3)/2;
        xWid = tempPos2(1) - tempPos1(1);
    end
        
    cbh = axes('position', [xSt, 0.04, xWid, 0.02]);
    imagesc(floor(cLim(1)):ceil(cLim(2)))
    xxtick2 = (ceil(cLim(1)/10)*10):5:(ceil(cLim(2)/10)*10);
    set(cbh, 'ytick', [], 'xtick', xxtick2-floor(cLim(1)), ...
             'xticklabel', arrayfun(@num2str, xxtick2, 'uniformoutput', 0))
    
end

set(imagesHand(:), 'edgecolor', 'none')
set(axh(:), 'color', [1,1,1]*0.85)


tilefigs % downloaded from matlabCentral

figH(end) = figure;
axes('position', [0.05, 0.05, 0.9, 0.9])
colormap(cMap)
imagesc(meanResp, cLim)
set(gcf, 'name', 'Sequential stimuli', 'units', 'normalized', 'position', [0.15, 0.3, 0.15, 0.6])

if nargout
    handleSt.axes = axh;
    handleSt.figs = figH;
    handleSt.images = imagesHand;
    
    varargout{1} = handleSt;
end

end
