function resultSt = analyzeRevPhiDataIndivStim(flightData, parSt)

% function resultSt = analyzeREvPhiDataIndivStim(flightData)
%
% This function analyzes the Data file generated by G4_Process_Data_flyingdetector
% for the revPhi experiments. The fucntions finds individual presentations
% of the revPhi stimulus and colapsses them for averaging 
%
% INPUT 
%
% flidhtData -      Data structure generated by G4_Process_Data_flyingdetector
%
% OUTPUT
% resultSt.time -           Time values per stimulus and presentation (not repeat
%                           since it is only one time vector
% resultSt.LmR -            Left minus right values from the appropriate time organized by cellXRepeatXpresentation 
% resultSt.LpR -            Same for left plus right
% resultSt.Inds -           cell array for binary vectors for the indices that were
%                           used for each stimulus and each repeat. 
% resultSt.FullVecInds -    indices for the full data vector (since
%                           itertrial data is stiched on and needs to be removed)
%
% parSt -                   parameter structure. includes the following
%                           fields 
%   .stepDur -              duration of pulse
%   .minPreLen -            minmal presentation length (used to chop trial
%                           into the right size)
%   .numPres -              either a single number (applied to all stim) or
%                           a 1XStim vector with a value for each revPhi
%                           stimulus (excludes optomotor)
%   .OMStimNum -            number for trials that are optomotor stim and
%                           not revPhi (since they require a different analysis)





%basic parameters
stepDur = parSt.stepDur; % since sampling rate is 1KHz
numPres = parSt.numPres;
minPresLen = parSt.minPresLen;  % minimal length of a single stimulus presentation
opStimNum = parSt.OMStimNum; 

relFrVal = [2,3];
preStimWin = 100; % in ms (when sampling is 1KHz)

frameChInd = find(cellfun(@(x) contains(x, 'Frame'), flightData.channelNames.timeseries));
LmRChInd = find(cellfun(@(x) contains(x, 'LmR'), flightData.channelNames.timeseries)); % should give 2 results
LpRChInd = find(cellfun(@(x) contains(x, 'LpR'), flightData.channelNames.timeseries)); 

assert(length(frameChInd) == 1, 'problem identifying frame channel')
assert(length(LmRChInd) == 2, 'problem identifying LmR channel')
assert(length(LpRChInd) == 1, 'problem identifying LpR channel')

LmRChInd = LmRChInd(2); 


dSiz = size(flightData.timeseries); 
numReps = dSiz(3);
numStim = dSiz(2); 
numRPStim = numStim - length(opStimNum);

if length(numPres) == 1
    numPres = ones(1, numRPStim) * numPres; 
else
    assert(length(numPres) == numRPStim, 'numPres should be either a single number or a vector with the same length as numStim')
end

resultCellM = cell(numStim, numReps);
resultCellP = resultCellM;
timeCell = cell(numStim,1);
relIndsCell = cell(numStim, numReps); 
relFullInds = nan(numStim, numReps, 2); 

timeDat = flightData.timestamps;


for ii=1:numStim
    
    failedReps = [];
    
    for jj=1:numReps
        
        tempFrDat = squeeze(flightData.timeseries(frameChInd, ii, jj, :));
        
        % finding the relevant indices (since that are nans and intertrial
        % samples mashed with it
        
        [nfrV, nFrBr] = SplitVec(~isnan(tempFrDat), 'equal', 'firstVal', 'bracket');
        relFrBr = nFrBr(nfrV, :); 
        nonNanLen = diff(relFrBr, [],2);
        [maxLen, maxLenInd] = max(nonNanLen); % can check length if neccessary
        
        relDatInds = relFrBr(maxLenInd, :); 
        
        relFrDat = tempFrDat(relDatInds(1):relDatInds(2)); 
        tempLmRDat = squeeze(flightData.timeseries(LmRChInd, ii, jj, relDatInds(1):relDatInds(2)));
        tempLpRDat = squeeze(flightData.timeseries(LpRChInd, ii, jj, relDatInds(1):relDatInds(2)));
        
        if ismember(ii, opStimNum)
            
            tempLmR = {tempLmRDat};
            tempLpR = {tempLpRDat};
            
            relIndsVec = true(1, relDatInds(2) - relDatInds(1) +1); 
            
            
        else
        
            [frVal,frInd] = SplitVec(relFrDat, 'equal', 'firstval', 'bracket');

            if ~all(ismember(relFrVal, frVal)) || maxLen < minPresLen % sometimes the frame vector is flat (stimulus wasnt presented)
                warning('Stimulus %d repeat %d was not presented', ii, jj)
                failedReps = [failedReps, jj];

                if length(failedReps) == numReps
                    fullStIndSeq = {}; % 
                end

                continue
            end


            stimInds = zeros(numPres(ii), 2); 

            for kk=1:length(relFrVal)

                tempIndFr  = frVal == relFrVal(kk);
                tempIndsFr  = frInd(tempIndFr, :); 

                tempGapLen = diff(tempIndsFr, [], 2);
                rndGapLen = round(tempGapLen/10) * 10;
                relGaps = rndGapLen == stepDur;

                assert(sum(relGaps) == numPres(ii), 'wrong number of stimulus presentation')

                stimInds(:, kk) = tempIndsFr(relGaps, kk); 


            end

            % checking again that the length is right
            indCheck = diff(stimInds, [], 2);
            rndIndChk = round(indCheck/10)*10;
            assert(all(rndIndChk == 2*stepDur), 'stim duration is not correct')

            fullStimInds = stimInds + [-preStimWin, preStimWin/2]; % adding the time before the stimulus, and half as much after

            % making all inds the same length
            indDiff = diff(fullStimInds, [], 2);
            addIndDiff = max(indDiff) - indDiff;
            fullStimIndsU = fullStimInds + [zeros(size(addIndDiff)), addIndDiff]; % adding samples in the end


            fullStIndSeq = arrayfun(@(x) fullStimIndsU(x,1):fullStimIndsU(x,2), 1:size(fullStimIndsU,1), 'uniformoutput', 0);
            tempLmR = cellfun(@(x) tempLmRDat(x), fullStIndSeq, 'uniformoutput', 0);
            tempLpR = cellfun(@(x) tempLpRDat(x), fullStIndSeq, 'uniformoutput', 0);
            
            relIndsVec = false(size(tempLmRDat)); 
            relIndsVec([fullStIndSeq{:}]) = true; 
        
        end
        
        resultCellM{ii, jj} = [tempLmR{:}]; 
        resultCellP{ii, jj} = [tempLpR{:}]; 
        
        relFullInds(ii,jj,:) = relDatInds; 
        
        relIndsCell{ii, jj} = relIndsVec; 
    end
    
    % since currently there is only one time vector
    tempTime = cellfun(@(x) timeDat(x), fullStIndSeq, 'uniformoutput', 0);
    timeCell{ii}  = [tempTime{:}]; 
    
end
    
resultSt.Time = timeCell; 
resultSt.LmR = resultCellM; 
resultSt.LpR = resultCellP; 
resultSt.Inds = relIndsCell;
resultSt.FullVecInds = relFullInds;


end
