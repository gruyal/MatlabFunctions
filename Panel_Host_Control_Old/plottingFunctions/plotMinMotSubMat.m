function varargout = plotMinMotSubMat(minMotSt, startInd, stopInd, plotOpts)

% function varargout = plotMinMotSubMat(minMotSt, startInd, stopInd)
%
% the function plots the minMot data with more direct comparisons of means.
% Data will be plotted as the submatrix spoanning all the combinations between start and stop inds. 
% function uses stimDur to shift data so it aligns with the apperance of
% the second bar
%
% INPUT
%
% minMotSt -        structure generated by calcMinMotMeans with .mean field
%                   in it, and data organized by bar position and timing
% start/stopInd-    indices for the positions to parse out of the total
%                   matrix. Should be given as the relative positions of first and second bar
%                   (0 is center)
% plotOpts -        plotting options
%   .plotReps:      logical. if TRUE plots the repeats
%   .zeroSecBar:    logical. if TRUE zero is the second bar appearance 
%   .timFlag:       1XK logical vector. If TRUE the corresponding timing (sim,
%                   firstbar disappear, firstbar remains) will be plotted.
%                   Should be same length as the third dim of minMotSt.data
%   .plotRec:       logical. if TRUE plots means of reciprocal position  < (ii, jj) at (jj, ii)> 
%   .compDiagResp:  Structure of 1XdatSiz(1) size. Should contain just the
%                   responses along the diagonal of a seperate stim. Mean
%                   response of the diagonal will be presented at second
%                   bar position. Structure dimensions are 1XdatSiz(1)
%                   since only one diagonal should be given. And since it
%                   is generated from the result of calcMinMotMeans and
%                   extracted from the data field, it shiould just have the
%                   .mean field for each entry
%                  
%
%
% OUTPUT
% if asked axh is given as output

datSiz = size(minMotSt(1).data);

defOptSt.plotReps = 0;
defOptSt.zeroSecBar = 0;
defOptSt.timFlag = ones(1, datSiz(3));
defOptSt.plotRec = 0;
defOptSt.compDiagResp = [];

if nargin < 4
    plotOptSt = defOptSt;
else
    plotOptSt = mergeStructures(defOptSt, plotOpts);
end

repFlag = logical(plotOptSt.plotReps);
zeroSecBarFlag = logical(plotOptSt.zeroSecBar);
timFlag = plotOptSt.timFlag;
recFlag = plotOptSt.plotRec;
diagSt = plotOptSt.compDiagResp;

if ~isempty(diagSt)
    assert(prod(size(diagSt) == [1,datSiz(1)]) == 1, 'compDiagResp structure is of wrong size')
end

assert(prod(ismember(timFlag, [0,1]))==1, 'timPlotFlag should be logical')
assert(length(timFlag) == datSiz(3), 'timPlotFlag should be the same length as size(minMotSt.data,3')
assert(ismember(recFlag, [0,1]), 'plotRec must be logical')

timeTit = {'Sim'; 'FB dis'; 'FB rem'};

assert(isfield(minMotSt(1), 'data'), 'minMotSt is missing data field')
assert(isfield(minMotSt(1).data, 'mean'), 'minMotSt is missing mean field')

stimDur = minMotSt.stimDur;
relTimeTit = timeTit(end-datSiz(3)+1:end);
relTimeTit = relTimeTit(logical(timFlag));


conStartInd = startInd+ ceil(datSiz(1)/2); % since center is zero position and it is always an odd number of positions
conStopInd = stopInd+ ceil(datSiz(1)/2); 

assert(ismember(conStartInd, 1:datSiz(1)), 'startInd index out of range')
assert(ismember(conStopInd, 1:datSiz(1)), 'stopInd index out of range')

relStart = min(conStartInd, conStopInd);
relStop = max(conStartInd, conStopInd);

relData = minMotSt(1).data(relStart:relStop, relStart:relStop, logical(timFlag));

if ~isempty(diagSt)
    relDiagSt = diagSt(relStart:relStop);
end


% calculate plot range based only on means
yyMaxCell = cellfun(@max, {relData.mean}, 'uniformoutput', 0);
yyMinCell = cellfun(@min, {relData.mean}, 'uniformoutput', 0);

yyAllMax = vertcat(yyMaxCell{:});
yyAllMin = vertcat(yyMinCell{:});

relYMax = max(yyAllMax(:,2));
relYMin = min(yyAllMin(:,2));

plotRange = relYMax-relYMin;
yyLim = [relYMin-plotRange/15, relYMax+plotRange/10];

%plotting the data

relDatSiz = size(relData);
if length(relDatSiz) < 3 %in case some timing is excluded
    rel3Dim = 1;
else
    rel3Dim = relDatSiz(3);
end

figure('units', 'normalized', 'position', [0.2, 0.1, 0.4, 0.5], 'name', num2str([startInd stopInd]));

posCell = generatePositionCell(0.05, 0.99, 0.04, 0.95, 0.005, 0.005, [relDatSiz(1), relDatSiz(2)]);


axh = zeros(relDatSiz(1), relDatSiz(2));

relCol = cbrewer('qual', 'Paired', 2*datSiz(3)); 
stimCol = [1,1,1]*0.85;
compDiagCol = [1,1,1]*0.65;

xxMin = 0;
xxMax = 0;

for ii=1:relDatSiz(1)
    
    for jj=1:relDatSiz(2)
        
        axh(ii, jj) = axes('position', posCell{ii, jj});
        hold on
        
        posDiff = abs(ii-jj);
        timeAdjust = posDiff*stimDur*zeroSecBarFlag;
        
        line([0-timeAdjust, 0-timeAdjust], yyLim, 'color', stimCol, 'linewidth', 1)
        line([0+posDiff*stimDur-timeAdjust, 0+posDiff*stimDur-timeAdjust], yyLim, 'color', stimCol, 'linewidth', 1)
        
        if ~isempty(diagSt)
            plot(relDiagSt(jj).mean(:,1), relDiagSt(jj).mean(:,2), 'color', compDiagCol, 'linewidth', 2.5)
        end
        
        for kk=1:rel3Dim
            
            if isempty(relData(ii,jj,kk).mean)
                continue
            end
            
            if repFlag
                repLen = length(relData(ii, jj, kk).reps);
                
                for rr=1:repLen
                    
                    repDat = relData(ii, jj, kk).reps{rr};
                    plot(repDat(:,1) - timeAdjust, repDat(:,2), 'color', relCol(2*kk-1, :), 'linewidth', 1)
                    
                end
                
            end
            
            if recFlag
                plot(relData(jj,ii,kk).mean(:,1) - timeAdjust, relData(jj,ii,kk).mean(:,2), 'color', relCol(2*kk-1, :), 'linewidth', 2.5)
            end
            
            plot(relData(ii,jj,kk).mean(:,1) - timeAdjust, relData(ii,jj,kk).mean(:,2), 'color', relCol(2*kk, :), 'linewidth', 3)
            
            if xxMin > relData(ii,jj,kk).mean(1,1)
                xxMin = relData(ii,jj,kk).mean(1,1);
            end
            
            if xxMax < relData(ii,jj,kk).mean(end,1)
                xxMax = relData(ii,jj,kk).mean(end,1);
            end
        end
        
    end
    hold off
end
            
            

hForLeg = flipud(findobj(axh(2,1), 'linewidth', 3));

             
% yyLim = get(axh(:), 'YLim');
% yyLim = vertcat(yyLim{:});
% yyMax = max(yyLim(:,2));
% yyMin = min(yyLim(:,1));

%xxLim = [-200, 300];

set(axh(:), 'YLim', [yyLim(1), yyLim(2)], 'XLim', [xxMin, xxMax])

xxTick = get(axh(1,1), 'xtick');
xxTickLab = get(axh(1,1), 'xticklabel');

yyTick = get(axh(1,1), 'ytick');
yyTickLab = get(axh(1,1), 'yticklabel');

set(axh(:), 'xtick', xxTick, 'xticklabel', {}, 'ytick', yyTick, 'yticklabel', {})
set(axh(1, :), 'yticklabel', yyTickLab)
set(axh(:, end), 'xticklabel', xxTickLab)

for ii=1:relDatSiz(1)
    relNumStr = num2str(ii+relStart-ceil(datSiz(1)/2)-1);
    if ii == ceil(relDatSiz(1)/2)
        title(axh(ii,1), {'First Bar Position'; relNumStr}) 
        ylabel(axh(1,ii), {'Second Bar Position';relNumStr})
    else
        title(axh(ii,1), relNumStr) 
        ylabel(axh(1,ii), relNumStr)
    end
end



legend(axh(end), hForLeg, relTimeTit, 'location', 'best')

if nargout > 0 
    varargout{1} = axh;
end


end
