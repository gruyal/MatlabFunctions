function varargout = plotResultsByArenaPosFlucBrightness(relProt, expRes, expSt, numInterVals, relMatrixDim)

% function varargout = plotResultsByMatrixPos(relIndex, expRes, expSt, relMatrixDim)
% This function plots the results based on position in the arena that were
% presented at random. It displays them stitched back together continuously
%
% INPUT
% relProt -     Protocal number from expSt
% expRes -      expResults structure generated by runPanelExperiment (has
%               protocolNum and dara fields)
% expSt -       expStructure generated by checkExpStruct (has pattern, posFun,
%               and protocol fields)
% numInterVals- number of empty frames between each presentation (based on the position function). 
% relMatrixDim- string ('x' or 'y') Dimension of the pattern matrix to use for plotting (by
%               default the biggest dimension would be used; if they are equal in size x would be used)
% 
%
% OUTPUT
% axhand -      (optional) axes handles to all the plots
 
samplingFreq = 10000; % assumes this for the calculation of findPositionFromVoltage

relIndex = find([expRes(:).protocolNum] == relProt);

if isempty(relIndex)
    error('No such protocol found')
end

datToPlot = expRes(relIndex).data(:,2);
protInd = expRes(relIndex).protocolNum;

tempProt = expSt.protocol(protInd);
patInd = tempProt.PatternID;
xxfreq = tempProt.FuncFreqX;
yyfreq = tempProt.FuncFreqY;


tempPat = expSt.pattern(patInd);
xxfr = tempPat.x_frames;
yyfr = tempPat.y_frames;


if nargin < 5
    
    if xxfr >= yyfr
        relMatrixDim = 'x';
    else 
        relMatrixDim = 'y';
    end
end


% finding the indices by which to divide the current recording

if strcmpi(relMatrixDim, 'x')
    relPosVec = expRes(relIndex).data(:, 3);
    relFreq = [samplingFreq, xxfreq];
    relFrames = xxfr;
elseif strcmpi(relMatrixDim, 'y')
    relPosVec = expRes(relIndex).data(:, 4);
    relFreq = [samplingFreq, yyfreq];
    relFrames = yyfr;
else
    error('relMatrixDim should be either x or y')
end

% samples interveining between stim presentation
addSamp = floor(relFreq(1)/relFreq(2) * numInterVals);


convPosVec = findPositionFromVoltage(relPosVec, relFreq, relFrames);
[spPosInds, spPosVal]= SplitVec(convPosVec, 'equal', 'bracket', 'firstval');

spPosInds = spPosInds(2:(end-1), :);
spPosVal = spPosVal(2:(end-1), :);

addSampMat = repmat([0, addSamp], size(spPosInds, 1), 1);
spPosInds = spPosInds + addSampMat;

% chunk data into bits based on value and make them the same length
posIds = unique(spPosVal);
spDatToPlot = cell(length(posIds), 1);

for ii=1:length(posIds)
    tempInds = find(spPosVal == posIds(ii));
    relIntervals = spPosInds(tempInds, :);

    maxInt = max(relIntervals(:,2) - relIntervals(:,1));
    
    tempDatToPlot = nan(length(tempInds), maxInt+100); %additional 10ms after the stim
    for jj=1:size(relIntervals, 1)
        
        tempDiff = diff(relIntervals(jj, :)); 
        tempDatToPlot(jj, 1:(tempDiff+100)) = datToPlot((relIntervals(jj, 1)):(relIntervals(jj, 2)+99));
    end
    
    spDatToPlot{ii} = tempDatToPlot;
    
end
    

% plotting the data

minLen = min(cellfun(@length, spDatToPlot));
modDatToPlot = cellfun(@(x) x(1:minLen), spDatToPlot, 'uniformoutput', 0);
matToPlot = cell2mat(modDatToPlot);

cmap = colormap('hot');
colormap(flipud(cmap))

imagesc(matToPlot*10) % to turn into mV
colorbar


if nargout
    varargout{1} = axhand;
end



end


