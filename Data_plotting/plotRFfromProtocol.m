function varargout = plotRFfromProtocol(relProt, expRes, expSt, relFreq, patternDir)

% function plotRFfromProtocol(relProt, expRes, expSt, relFreq, patternDir)
%
% This function calculates the response strength at each position on the
% arena by multiplying the 90th quantile of each response window with the pattern
% displayed at that time (separating Bright and Dark maps)
% Function assumes a 15ms delay between presentation and response for its
% calculations
%
% INPUT
%
% relProt -     Protocal number from expSt
% expRes -      expResults structure generated by runPanelExperiment (has
%               protocolNum and dara fields)
% expSt -       expStructure generated by checkExpStruct (has pattern, posFun,
%               and protocol fields)
% relFreq -     freqeuncy with which pattern was played (recorded in
%               expProts)
% patternDir -  directory of relevant pattern files
%
% OUTPUT (optional)
%
% output(1) -   matrix from which plots are generated. Matrix dimensions are 
%               x X y x 2, where X and Y are determined by the first 2 dims of
%               pattern.Pats and the third dim is light pattern for the first
%               amd dark for the second
% output(2) -   2 element vector of figure handles. 1 is light and 2 dark,
%               and if one of them is missing the handle is zero (but position are the
%               same)



respDelay = 15; % in ms (based on observations (might need to change)
samplingFreq = 10000; % assumes this for the calculation of findPositionFromVoltage

sampDelay = samplingFreq/1000 * respDelay;

relIndex = find([expRes(:).protocolNum] == relProt);

if length(relIndex) > 1
    prompt = [num2str(length(relIndex)), ' protocols found, which one would you like to plot? '];
    uInput = input(prompt);
    if uInput > length(relIndex)
        error('Number exceeds protocols found')
    end
    relIndex = relIndex(uInput);
end



datToPlot = expRes(relIndex).data(:,2) *10; % to convert to mV
protInd = expRes(relIndex).protocolNum;

tempProt = expSt.protocol(protInd);
patInd = tempProt.PatternID;
xxfreq = relFreq;
yyfreq = relFreq;


tempPat = expSt.pattern(patInd);
xxfr = tempPat.x_frames;
yyfr = tempPat.y_frames;

load(fullfile(patternDir, [tempPat.name '.mat']))
pats = pattern.Pats;
uVals = unique(pats);

if length(intersect(uVals,[0;3;7])) ~= length(uVals)
    error('function designed for patterns with GS values 0,3 and 7 only')
end

pats(1:2, 20:22, :, :) = 3; % removing the blinking square;
lightMaskPat = zeros(size(pats));
darkMaskPat = lightMaskPat;
darkMaskPat(pats == 0) = 1;
lightMaskPat(pats == 7) = 1;

lightRF = zeros(size(pats, 1), size(pats, 2));
darkRF = lightRF; 
lightNorm = lightRF;
darkNorm = darkRF;

% default for the current protocol
relMatrixDim = 'x';



% finding the indices by which to divide the current recording

if strcmpi(relMatrixDim, 'x')
    relPosVec = expRes(relIndex).data(:, 3);
    relFreq = [samplingFreq, xxfreq];
    relFrames = xxfr;
    secFrames = yyfr;
    secPosVec = expRes(relIndex).data(:, 4);
elseif strcmpi(relMatrixDim, 'y')
    relPosVec = expRes(relIndex).data(:, 4);
    relFreq = [samplingFreq, yyfreq];
    relFrames = yyfr;
    secFrames = xxfr;
    secPosVec = expRes(relIndex).data(:, 3);
else
    error('relMatrixDim should be either x or y')
end

convPosVec = findPositionFromVoltage(relPosVec, relFreq, relFrames);
secConvPosVec = findPositionFromVoltage(secPosVec, relFreq, secFrames);
[spPosInds, spPosVal]= SplitVec(convPosVec, 'equal', 'bracket', 'firstval');

spPosInds = spPosInds(2:(end-1), :);
spPosVal = spPosVal(2:(end-1), :);

counter =0;
prevResp = -1;

%uPosVals = unique(spPosVals);

for ii=1:length(spPosVal)
    
    % determine baseline as 15ms before and after window appears in a particular x location
    tempBase = mean(datToPlot((spPosInds(ii,1)-sampDelay):(spPosInds(ii,1)+sampDelay)));
    tempRelData = datToPlot((spPosInds(ii,1)+sampDelay):(spPosInds(ii,2)+sampDelay));
    [tempSecPosInds, tempSecVals] = SplitVec(secConvPosVec(spPosInds(ii,1):spPosInds(ii,2)), 'equal', 'bracket', 'firstval');
    
    for jj=1:length(tempSecVals)
        
        tempResp = quantile(tempRelData(tempSecPosInds(jj,1):tempSecPosInds(jj,2)), 0.9) - tempBase;
        buff = tempResp;
        
        
        if tempResp < prevResp
            counter = counter+1;
            tempResp = 0;
        end
        
        lightRF = lightRF + tempResp * lightMaskPat(:,:,spPosVal(ii), tempSecVals(jj));
        darkRF =  darkRF + tempResp * darkMaskPat(:,:,spPosVal(ii), tempSecVals(jj));
        lightNorm = lightNorm + lightMaskPat(:,:,spPosVal(ii), tempSecVals(jj));
        darkNorm = darkNorm + darkMaskPat(:,:,spPosVal(ii), tempSecVals(jj));
        
        
        prevResp = buff;
    end
    
    
    
end
        

lightRF = lightRF./(lightNorm+eps);
darkRF = darkRF./(darkNorm+eps);

figh = zeros(1,2);

if sum(lightNorm(:) > 0)
    figh(1) = figure('units', 'normalized', 'position', [0.3, 0.45, 0.45, 0.25]);
    cmap = colormap('hot');
    imagesc(lightRF, [0, max(lightRF(:))]);
    axis equal
    colormap(flipud(cmap))
    set(gca, 'xlim', [0.5, size(lightRF, 2)], 'ylim', [0.5, size(lightRF, 1)], ...
        'xtick', [], 'ytick', [])
    hold on
    % adds red lines
    for ii=0.5:8:size(lightRF, 2)
        line([ii, ii], [0, size(lightRF, 1)], 'color', 'r', 'linewidth', 1)
    end

    for ii=0.5:8:size(lightRF, 1)
        line([0, size(lightRF, 2)], [ii, ii], 'color', 'r', 'linewidth', 1)
    end
    hold off
    
end


if sum(darkNorm(:) > 0)
    figh(2) = figure('units', 'normalized', 'position', [0.3, 0.2, 0.45, 0.25]);
    cmap = colormap('hot');
    imagesc(darkRF, [0, max(darkRF(:))]);
    axis equal
    colormap(rot90(cmap,2))
    set(gca, 'xlim', [0.5, size(darkRF, 2)], 'ylim', [0.5, size(darkRF, 1)], ...
        'xtick', [], 'ytick', [])
    hold on
    % adds red lines
    for ii=0.5:8:size(darkRF, 2)
        line([ii, ii], [0, size(darkRF, 1)], 'color', 'r', 'linewidth', 1)
    end

    for ii=0.5:8:size(darkRF, 1)
        line([0, size(darkRF, 2)], [ii, ii], 'color', 'r', 'linewidth', 1)
    end
    hold off
     
end



combRF(:,:,1) = lightRF;
combRF(:,:,2) = darkRF;


if nargout == 1
    varargout{1} = combRF; 
elseif nargout ==2
    varargout{1} = combRF; 
    varargout{2} = figh; 
end










end