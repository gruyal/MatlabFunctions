function varargout = plotResultsByMatrixXYPosContinuous(relProt, expRes, expSt, subplotSpecs)

% function varargout = plotResultsByMatrixXYPosContinuous(relIndex, expRes, expSt, subplotSpecs)
% This function plots the results based on the both X and Y values when one
% dimesion is constant and the other is continuous 
% To be used with CrossRF
%
% INPUT
% relProt -     Protocal number from expSt
% expRes -      expResults structure generated by runPanelExperiment (has
%               protocolNum and dara fields)
% expSt -       expStructure generated by checkExpStruct (has pattern, posFun,
%               and protocol fields)
% subplotSpecs- (optional) 2 element vector giving rows and columns in
%               final figure
%
% OUTPUT
% axhand -      (optional) axes handles to all the plots


samplingFreq = 10000; % assumes this for the calculation of findPositionFromVoltage

relIndex = find([expRes(:).protocolNum] == relProt);

datToPlot = expRes(relIndex).data(:,2);
protInd = expRes(relIndex).protocolNum;

tempProt = expSt.protocol(protInd);
patInd = tempProt.PatternID;
xxfreq = tempProt.FuncFreqX;
yyfreq = tempProt.FuncFreqY;

% samples interveining between stim presentation
%addSamp = floor(samplingFreq/xxfreq * numInterVals);


tempPat = expSt.pattern(patInd);
xxfr = tempPat.x_frames;
yyfr = tempPat.y_frames;


convPosVecX = findPositionFromVoltage(expRes(relIndex).data(:, 3), [samplingFreq, xxfreq], xxfr);
[spPosIndsX, spPosValX]= SplitVec(convPosVecX, 'equal', 'bracket', 'firstval');

spPosIndsX = spPosIndsX(2:(end-1), :);
spPosValX = spPosValX(2:(end-1), :);


convPosVecY = findPositionFromVoltage(expRes(relIndex).data(:, 4), [samplingFreq,yyfreq], yyfr);
[spPosIndsY, spPosValY]= SplitVec(convPosVecY, 'equal', 'bracket', 'firstval');

spPosIndsY = spPosIndsY(2:(end-1), :);
spPosValY = spPosValY(2:(end-1), :);

% determine which dimension is cont and which random
if      median(diff(spPosIndsX,1, 2)) < median(diff(spPosIndsY,1, 2))
    contDim = 1;
    randDim = 2;
elseif  median(diff(spPosIndsX,1, 2)) > median(diff(spPosIndsY,1, 2))
    contDim = 2;
    randDim = 1;
end

% chunk data into bits based on value and make them the same length
posIdsX = unique(spPosValX);
posIdsY = unique(spPosValY);

spPosValCell = {spPosValX; spPosValY};
spPosIndsCell = {spPosIndsX; spPosIndsY};
posIdsCell = {posIdsX; posIdsY};
convPosCell = {convPosVecX; convPosVecY};


if sign(median(diff(spPosValCell{contDim}))) == -1 % value in matrix is decreasing
    tempInts =  SplitVec(spPosValCell{contDim}, 'reverse', 'bracket');
    tempInts =  tempInts(diff(tempInts, 1, 2) > 0,:); % selects only the parts where the pattern moves continuously
    relIntervals = [spPosIndsCell{contDim}(tempInts(:,1),1), spPosIndsCell{contDim}(tempInts(:,2),2)];
else % value is increasing
    tempInts =  SplitVec(spPosValCell{contDim}, 'consecutive', 'bracket');
    tempInts =  tempInts(diff(tempInts, 1, 2) > 0,:); % selects only the parts where the pattern moves continuously
    relIntervals = [spPosIndsCell{contDim}(tempInts(:,1),1), spPosIndsCell{contDim}(tempInts(:,2),2)];
end

relRandSamps = round(mean(relIntervals, 2));
relRandVals = convPosCell{randDim}(relRandSamps);

uniRandVals = unique(relRandVals);

spDatToPlot = cell(1, length(uniRandVals));

for ii=1:length(uniRandVals)
    tempRandInds = find(relRandVals == uniRandVals(ii));
    minInt = min(relIntervals(tempRandInds,2) - relIntervals(tempRandInds,1));
    tempDatToPlot = zeros(length(tempRandInds), minInt+200); % adds 100 samples before and after
    tempPosToPlot = tempDatToPlot;
    for jj=1:length(tempRandInds)
        
        postAdd = 100 - diff(relIntervals(tempRandInds(jj), :)) + minInt;
        tempDatToPlot(jj, :) = datToPlot((relIntervals(tempRandInds(jj), 1)-99):(relIntervals(tempRandInds(jj), 2)+postAdd));
        
        % to label the positions of the continuous position
        if ii == length(uniRandVals)
            tempPosToPlot(jj, :) = convPosCell{contDim}((relIntervals(tempRandInds(jj), 1)-99):(relIntervals(tempRandInds(jj), 2)+postAdd));
        end
        
    end
    spDatToPlot{ii} = tempDatToPlot;
    
end
 
indvPosToPlot = median(tempPosToPlot);
[spIndv, spIndvVal] =  SplitVec(indvPosToPlot, 'equal', 'bracket', 'firstval');

% plotting the data

axhand = zeros(size(spDatToPlot));

yyall = quantile(datToPlot, [0.0001, 0.9999])*10;
yyPosPos = quantile(datToPlot, 0.01)*10;
if nargin < 4
    subplotSpecs = [1, length(uniRandVals)];
end

posCell = generatePositionCell(0.05, 0.95, 0.05, 0.95, 0.02, 0.02, subplotSpecs);

figure
for ii=1:length(uniRandVals)
    
    axhand(ii) = axes('position', posCell{ii});
    plot(spDatToPlot{ii}'*10, 'color', [1 1 1]*0.8) % converts to mV
    hold on 
    plot(mean(spDatToPlot{ii})*10, 'color', 'r', 'linewidth', 2)
    if ii==length(uniRandVals)
        for jj=1:length(spIndvVal)
            tempFac = double(rem(jj, 2) == 0);
            line(spIndv(jj,:), [yyPosPos, yyPosPos], 'color', [1,1,1]* tempFac)
            if tempFac
                text(mean(spIndv(jj,:)), yyPosPos, num2str(spIndvVal(jj)), ...
                    'color', 'r', 'HorizontalAlignment', 'center')
            end
        end
    end
    hold off
    
    title(['Position:', num2str(uniRandVals(ii))])

end

set([axhand(:)], 'ylim', yyall, ...
    'xlim', [0, max(cellfun(@length, spDatToPlot))])
set(axhand(1:end-1), 'xticklabel', {})     
if nargout
    varargout{1} = axhand;
end



end


