function varargout = plotResultsBySingleSquare(relProt, expRes, expSt)

% function varargout = plotResultsByMatrixPos(relIndex, expRes, expSt, relMatrixDim, subplotSpecs)
% This function plots the results for the single square protocol that moves
% in 4 directions with jitter
%
% INPUT
% relProt -     Protocal number from expSt
% expRes -      expResults structure generated by runPanelExperiment (has
%               protocolNum and dara fields)
% expSt -       expStructure generated by checkExpStruct (has pattern, posFun,
%               and protocol fields)
%
% OUTPUT
% axhand -      (optional) axes handles to all the plots


samplingFreq = 10000; % assumes this for the calculation of findPositionFromVoltage

relIndex = find([expRes(:).protocolNum] == relProt);

datToPlot = expRes(relIndex).data(:,2);
protInd = expRes(relIndex).protocolNum;

tempProt = expSt.protocol(protInd);
patInd = tempProt.PatternID;
xxfreq = tempProt.FuncFreqX;
yyfreq = tempProt.FuncFreqY;


tempPat = expSt.pattern(patInd);
xxfr = tempPat.x_frames;
yyfr = tempPat.y_frames;


convPosVecX = findPositionFromVoltage(expRes(relIndex).data(:,3), [samplingFreq, xxfreq], xxfr);
convPosVecY = findPositionFromVoltage(expRes(relIndex).data(:,4), [samplingFreq, yyfreq], yyfr);


xxdiff = diff(convPosVecX);
yydiff = diff(convPosVecY);

%since the movement is for 15 positions
xxlog = double(abs(xxdiff) > 10); 
yylog = double(abs(yydiff) > 10);

sampBack = samplingFreq/xxfreq * 11;
buffer = samplingFreq/xxfreq * 15; % to get rid of double results from wraping 

xxshifts = find(xxlog);
yyshifts = find(yylog);

for ii=2:(length(xxshifts)-1) %first and last are changes due to start and end of presentation
    if sum(xxlog((xxshifts(ii)+1):(xxshifts(ii)+buffer))) % if there is a 1 close by it is a sign that the posFunc wrapped around
        xxlog(xxshifts(ii)) = 0;
    end
end
for ii=2:(length(yyshifts)-1)
    if sum(yylog((yyshifts(ii)+1):(yyshifts(ii)+buffer))) % if there is a 1 close by it is a sign that the posFunc wrapped around
        yylog(yyshifts(ii)) = 0;
    end
end

xxshifts = find(xxlog);
yyshifts = find(yylog);

for ii=2:length(xxshifts) % the first jump is from nothing to presenting pattern
    [~ , ~ , temp]  = find(xxdiff((xxshifts(ii)-sampBack):(xxshifts(ii)-1)));
    xxlog(xxshifts(ii)) = sign(median(temp)); % again to account for wrap around positions
end

for ii=2:length(yyshifts)
    [~ , ~ , temp]  = find(yydiff((yyshifts(ii)-sampBack):(yyshifts(ii)-1)));
    yylog(yyshifts(ii)) = sign(median(temp)); % again to account for wrap around positions
end

combVec = xxlog+yylog; % there is probably a better way to do this
combVecInds = find(combVec);
mvPeriod = round(median(diff(combVecInds)) - 100); % separates mv a bit
postSamp = 500; % 50ms after mv end 

spResToPlot = cell(1,4);
sigToPlot = cell(1,4);

for ii=1:length(combVecInds)
    tempind = combVecInds(ii);
    relRange = (tempind - mvPeriod):(tempind + postSamp);
    if (xxlog(tempind) * sum(yylog((tempind-10):(tempind+10)))) %if they change together (just in the beginning)
        continue
    elseif (yylog(tempind) * sum(xxlog((tempind-10):(tempind+10)))) %if they change together (just in the beginning)
        continue
    elseif xxlog(tempind) == 1
        spResToPlot{1} = horzcat(spResToPlot{1}, datToPlot(relRange));
        if isempty(sigToPlot{1})
            sigToPlot{1} = [convPosVecX(relRange),convPosVecY(relRange)];
        end
    elseif xxlog(tempind) == -1
        spResToPlot{2} = horzcat(spResToPlot{2}, datToPlot(relRange));
        if isempty(sigToPlot{2})
            sigToPlot{2} = [convPosVecX(relRange),convPosVecY(relRange)];
        end
    elseif yylog(tempind) == 1
        spResToPlot{3} = horzcat(spResToPlot{3}, datToPlot(relRange));
        if isempty(sigToPlot{3})
            sigToPlot{3} = [convPosVecX(relRange),convPosVecY(relRange)];
        end
    elseif yylog(tempind) == -1
        spResToPlot{4} = horzcat(spResToPlot{4}, datToPlot(relRange));
        if isempty(sigToPlot{4})
            sigToPlot{4} = [convPosVecX(relRange),convPosVecY(relRange)];
        end
    end
end

dirTit = {'Right', 'Left', 'Up', 'Down'};


% plotting the data

posCell = generatePositionCell(0.05, 0.95, 0.05, 0.95, 0.07, 0.07, [2, 2]);

axhand = zeros(2, length(spResToPlot));

yyall = quantile(datToPlot, [0.001, 0.999])*10;
mulFac = round(diff(yyall)/4);

figure

for ii=1:length(spResToPlot)

    axhand(1, ii) = axes('position', posCell{ii} + [0, 0.12, 0, -0.12]); %spilt axes into 2
    hold on
    plot(spResToPlot{ii}*10, 'color', [1 1 1]*0.8) % converts to mV 
    plot(mean(spResToPlot{ii}, 2)*10, 'color', 'r', 'linewidth', 2)
    hold off
    title(dirTit{ii})
    
    axhand(2, ii) = axes('position', [posCell{ii}(1), posCell{ii}(2), posCell{ii}(3), 0.1]);
    plot(sigToPlot{ii}, 'linewidth', 1)
    
end

set(axhand(1, :), 'ylim', yyall, 'xticklabel', {})
set(axhand(:), 'xlim', [0, size(spResToPlot{1}, 1)])
    
if nargout
    varargout{1} = axhand;
end



end


