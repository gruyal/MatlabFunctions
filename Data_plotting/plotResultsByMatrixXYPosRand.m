function varargout = plotResultsByMatrixXYPosRand(relProt, expRes, expSt, numEmptyFrames)

% function varargout = plotResultsByMatrixXYPosContinuous(relIndex, expRes, expSt, subplotSpecs)
% This function plots the results based on the both X and Y values when
% both are random
% To be used with CrossRF
%
% INPUT
% relProt -     Protocal number from expSt
% expRes -      expResults structure generated by runPanelExperiment (has
%               protocolNum and dara fields)
% expSt -       expStructure generated by checkExpStruct (has pattern, posFun,
%               and protocol fields)
% numEmptyFrames - (optional) The number of empty positions in the position
%                  vectors in between presentation. if not given 3 is
%                  assumed
% 
% OUTPUT
% axhand -      (optional) axes handles to all the plots


clf

if nargin < 4
    numEmptyFrames = 3;
end


samplingFreq = 10000; % assumes this for the calculation of findPositionFromVoltage

relIndex = find([expRes(:).protocolNum] == relProt);

datToPlot = expRes(relIndex).data(:,2)*10; % to convert to mV
yyrange = quantile(datToPlot, [0.0001, 0.999]);
fudge = (yyrange(2)-yyrange(1))/10;
yylim = [yyrange(1)-fudge, yyrange(2)+fudge];

protInd = expRes(relIndex).protocolNum;

tempProt = expSt.protocol(protInd);
patInd = tempProt.PatternID;
xxfreq = tempProt.FuncFreqX;
yyfreq = tempProt.FuncFreqY;

% samples interveining between stim presentation
%addSamp = floor(samplingFreq/xxfreq * numInterVals);


tempPat = expSt.pattern(patInd);
xxfr = tempPat.x_frames;
yyfr = tempPat.y_frames;


convPosVecX = findPositionFromVoltage(expRes(relIndex).data(:, 3), [samplingFreq, xxfreq], xxfr);
[spPosIndsX, spPosValX]= SplitVec(convPosVecX, 'equal', 'bracket', 'firstval');

spPosIndsX = spPosIndsX(2:(end-1), :);
spPosValX = spPosValX(2:(end-1), :);


convPosVecY = findPositionFromVoltage(expRes(relIndex).data(:, 4), [samplingFreq,yyfreq], yyfr);
[spPosIndsY, spPosValY]= SplitVec(convPosVecY, 'equal', 'bracket', 'firstval');

spPosIndsY = spPosIndsY(2:(end-1), :);
spPosValY = spPosValY(2:(end-1), :);

uniXval = unique(spPosValX);
uniYval = unique(spPosValY);
% exclude the zero position

[~, maxXInd] = max(arrayfun(@(x) length(find(spPosValX == x)), uniXval));
[~, maxYInd] = max(arrayfun(@(x) length(find(spPosValY == x)), uniYval));

uniXval = setdiff(uniXval, uniXval(maxXInd));
uniYval = setdiff(uniYval, uniYval(maxYInd));

cellToPlot = cell(length(uniXval), length(uniYval));

% chunk data based on position

for ii=1:length(spPosValX)
    tempXInd = find(uniXval == spPosValX(ii));
    tempYInd = find(uniYval == spPosValY(ii));
    
    if ~isempty(tempXInd) && ~isempty(tempYInd)
        currSiz = length(cellToPlot{tempXInd, tempYInd});
        cellToPlot{tempXInd, tempYInd}{currSiz+1} = datToPlot(spPosIndsX(ii, 1):(spPosIndsY(ii, 2)+samplingFreq/xxfreq*numEmptyFrames));
    end
end



% plotting the data

posCell = generatePositionCell(0.04, 0.99, 0.04, 0.98, 0.012, 0.012, size(cellToPlot));
allAxH = cellfun(@(x) axes('position', x), fliplr(posCell));
set(allAxH(:), 'nextplot', 'add')
maxLen = 0;


for ii=1:length(uniXval)
    for jj=1:length(uniYval)
        minLen = min(cellfun(@length, cellToPlot{ii, jj}));
        if maxLen < minLen
            maxLen = minLen;
        end
        tempMat = cellfun(@(x) x(1:minLen), cellToPlot{ii, jj}, 'uniformoutput', 0);
        tempMat = [tempMat{:}];     
        
        plot(allAxH(ii, jj), tempMat, 'color', [1 1 1]*0.8)
        
        plot(allAxH(ii, jj),mean(tempMat, 2), 'color', 'r', 'linewidth', 2)
        title(allAxH(ii, jj), ['X:', num2str(uniXval(ii)), ' Y:', num2str(uniYval(jj))])
    end
end
    
% allyy = get(allAxH(:), 'ylim');
% allyy = vertcat(allyy{:});
set(allAxH(:), 'xlim', [1, maxLen], 'ylim', yylim)
xxtick = get(allAxH(1), 'xtick');
yytick = get(allAxH(1), 'ytick');
set(allAxH(:), 'ytick', [], 'xtick', [])
set(allAxH(:, 1), 'xtick', xxtick)
set(allAxH(1, :), 'ytick', yytick)

chh = get(gcf, 'children');
set(gcf, 'children', flipud(chh))

if nargout 
    varargout{1} = allAxH;
end



end


