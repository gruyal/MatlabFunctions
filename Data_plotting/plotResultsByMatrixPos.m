function varargout = plotResultsByMatrixPos(relProt, expRes, expSt, relFreq, rangeAll, subplotSpecs, relMatrixDim)

% function varargout = plotResultsByMatrixPos(relIndex, expRes, expSt, relMatrixDim, subplotSpecs)
% This function plots the results based on the relMatrixDim values
%
% INPUT
% relProt -     Protocal number from expSt
% expRes -      expResults structure generated by runPanelExperiment (has
%               protocolNum and dara fields)
% expSt -       expStructure generated by checkExpStruct (has pattern, posFun,
%               and protocol fields)
% relFreq -     freqeuncy with which pattern was played (recorded in
%               expProts)
% relMatrixDim- string ('x' or 'y') Dimension of the pattern matrix to use for plotting (by
%               default the biggest dimension would be used; if they are equal in size x would be used)
% subplotSpecs- (optional) 3 element vector specifying (1) number of
%               figures (2) number of columns in each figure (3) number of rows in each
%               figure. Default is one figure with 6 columns and however
%               many rows needed
% rangeAll -     (optional) logical. if 1 set the ylim to the entire range. Defualt
%               sets the range between the 0.001 and the 0.999 percentiles
%
% OUTPUT
% axhand -      (optional) axes handles to all the plots


if nargin < 5
    rangeAll = 0;
end

samplingFreq = 10000; % assumes this for the calculation of findPositionFromVoltage

relIndex = find([expRes(:).protocolNum] == relProt);

if length(relIndex) > 1
    prompt = [num2str(length(relIndex)), ' protocols found, which one would you like to plot? '];
    uInput = input(prompt);
    if uInput > length(relIndex)
        error('Number exceeds protocols found')
    end
    relIndex = relIndex(uInput);
end



datToPlot = expRes(relIndex).data(:,2);
protInd = expRes(relIndex).protocolNum;

tempProt = expSt.protocol(protInd);
patInd = tempProt.PatternID;
xxfreq = relFreq;
yyfreq = relFreq;


tempPat = expSt.pattern(patInd);
xxfr = tempPat.x_frames;
yyfr = tempPat.y_frames;


if nargin < 7
    
    if xxfr >= yyfr
        relMatrixDim = 'x';
    else 
        relMatrixDim = 'y';
    end
end


% finding the indices by which to divide the current recording

if strcmpi(relMatrixDim, 'x')
    relPosVec = expRes(relIndex).data(:, 3);
    relFreq = [samplingFreq, xxfreq];
    relFrames = xxfr;
    secFrames = yyfr;
    secPosVec = expRes(relIndex).data(:, 4);
elseif strcmpi(relMatrixDim, 'y')
    relPosVec = expRes(relIndex).data(:, 4);
    relFreq = [samplingFreq, yyfreq];
    relFrames = yyfr;
    secFrames = xxfr;
    secPosVec = expRes(relIndex).data(:, 3);
else
    error('relMatrixDim should be either x or y')
end

convPosVec = findPositionFromVoltage(relPosVec, relFreq, relFrames);
secConvPosVec = findPositionFromVoltage(secPosVec, relFreq, secFrames);
[spPosInds, spPosVal]= SplitVec(convPosVec, 'equal', 'bracket', 'firstval');

spPosInds = spPosInds(2:(end-1), :);
spPosVal = spPosVal(2:(end-1), :);


% chunk data into bits based on value and make them the same length
posIds = unique(spPosVal);
spDatToPlot = cell(length(posIds), 1);
sigToPlot = spDatToPlot;

for ii=1:length(posIds)
    tempInds = find(spPosVal == posIds(ii));
    relIntervals = spPosInds(tempInds, :);
    minInt = min(relIntervals(:,2) - relIntervals(:,1));
    
    tempDatToPlot = zeros(length(tempInds), minInt+200); % adds 100 sample before and after
    tempSig = tempDatToPlot;
    for jj=1:length(relIntervals)
        postAdd = 100 - diff(relIntervals(jj, :)) + minInt;
        tempDatToPlot(jj, :) = datToPlot((relIntervals(jj, 1)-99):(relIntervals(jj, 2)+postAdd));
        tempSig(jj,:) = secConvPosVec((relIntervals(jj, 1)-99):(relIntervals(jj, 2)+postAdd));
    end
    
    spDatToPlot{ii} = tempDatToPlot;
    sigToPlot{ii} = median(tempSig);
    
end
    

% plotting the data

if nargin < 6
    if length(unique(spPosVal)) == 9
        subplotSpecs = [1, 3, 3];
    else
        subplotSpecs = [1, 6, ceil(length(unique(spPosVal))/6)];
    end
end

posCell = generatePositionCell(0.05, 0.95, 0.05, 0.95, 0.02, 0.02, subplotSpecs(2:3));

counter = 0;
axhand = zeros(1, length(spDatToPlot));

if rangeAll == 1
    tempRange = [min(datToPlot), max(datToPlot)];
    yyall = [tempRange(1)-diff(tempRange)/20, tempRange(2)+diff(tempRange)/20]*10;
else
    yyall = quantile(datToPlot, [0.001, 0.999])*10;
end
    
sigmax = max(cellfun(@max, sigToPlot));

for ii=1:subplotSpecs(1)
    
    figure
    set(gcf, 'units', 'normalized', 'position', [0.25, 0.25, 0.5, 0.6])
    
    for jj=1:(subplotSpecs(2)*subplotSpecs(3))
        counter=counter+1;
        
        if counter > length(spDatToPlot)
        break
        end
        
        axhand(counter) = axes('position', posCell{jj});
        hold on
        tempDPlot = spDatToPlot{counter}'*10; % converts to mV
        cols = linspace(0.4, 0.9, size(spDatToPlot{counter}, 1))' * [1, 1, 1];
        for kk=1:size(spDatToPlot{counter}, 1)
            plot(tempDPlot(:,kk), 'color', cols(kk, :))
        end
        plot(sigToPlot{counter}/sigmax * (diff(yyall)/2) +yyall(1), 'color', 'k', 'linewidth', 2)
        plot(median(spDatToPlot{counter})*10, 'color', 'r', 'linewidth', 2)
        hold off
        set(gca, 'xlim', [0, size(spDatToPlot{counter}, 2)])
        title(num2str(posIds(counter)))
        
    end
    
    
    
end

set(axhand(:), 'ylim', yyall)

    
if nargout
    varargout{1} = axhand;
end



end


