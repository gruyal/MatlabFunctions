function behavExpStruct = generateControllerFiles(direc)

% function generateControllerFiles(direc)
%
% This function takes a directory with PatNPosFunc files (generated by
% makePatandPosFuncForBExp_barExpand) and turns the files into pat anf fun
% files for the controller. If no directory is given working directory is
% used
%
% NOTE!     1) The right path should be entered for the panel controller
%           configuration file. 
%           2) pat anf fun files in the panel controller directory will be
%           deleted and replaced with the ones generated by this function.
%
% OUTPUT
% behavExpStruct -      structure with fields describing all the patterns
%                       and position functions that were generated for this experiment. 


% basic parameters
block_size = 512; % all data must be in units of block size
Header_block = zeros(1, block_size);
panelContConfigFile = 'F:\Panel Host\Support Files\HHMI Panels Configuration.ini';

%clean the temp folder
pConfig = fileread(panelContConfigFile);
pConfigFormatted = textscan(pConfig, '%s');
pathInd = find(cellfun(@(x) strcmp(x, '[Pattern]'), pConfigFormatted{1})) + 3; % add 3 since there is 'path', and '=' in between
temp_path = pConfigFormatted{1}{pathInd};

pathIndFunc = find(cellfun(@(x) strcmp(x, '[Function]'), pConfigFormatted{1})) + 3; % add 3 since there is 'path', and '=' in between
temp_pathFunc = pConfigFormatted{1}{pathIndFunc};


dos(['del /Q "' temp_path '\*.pat"']); 
dos(['del /Q "' temp_pathFunc '\*.fun"']); 


if nargin < 1
    direc = pwd;
end

dirSt = dir(fullfile(direc, 'PatNPosFunc*.mat'));

assert(length(dirSt > 0), 'No PatNPosFunc files in this directory')

stat = 0;
pos_func_counter = 0;

for ii=1:length(dirSt)
    
    load(fullfile(direc, dirSt(1).name))
    
    behavExpStruct(ii).patName = dirSt(1).name;
    
    num_panels = pattern.num_panels;
    gs_val = pattern.gs_val;
    current_frame_size = num_panels*gs_val*8;
    x_num = pattern.x_num;
    y_num = pattern.y_num;
    
    blocks_per_frame = ceil(current_frame_size/block_size);
    current_num_frames = x_num*y_num;
    num_blocks_needed = blocks_per_frame*current_num_frames;
    
    Header_block(1:8) = [dec2char(x_num,2), dec2char(y_num,2), num_panels, gs_val, dec2char(current_frame_size,2)];
    
    Pattern_Data = zeros(1, num_blocks_needed*block_size);
    
    block_indexer = 1;  % points to the first block
    % now write all of the frame info
    for jj = 1:current_num_frames
        sd_start_address = (block_indexer - 1)*block_size + 1;
        sd_end_address = sd_start_address + current_frame_size - 1;    
        % always forced to start frame at a block boundary
        pat_start_address = (jj - 1)*current_frame_size + 1;
        pat_end_address = pat_start_address + current_frame_size - 1;    
        Pattern_Data(sd_start_address:sd_end_address) = pattern.data(pat_start_address:pat_end_address);
        block_indexer = block_indexer + blocks_per_frame;
    end    

    Data_to_write = [Header_block Pattern_Data];
    
    pads = repmat('0', 1, 4-length(num2str(ii)));
    patFileName = ['pat', pads, num2str(ii) '.pat'];
    
    % pattern file
    
    fid = fopen([temp_path '\' patFileName] , 'w');
    assert(fid ~= -1, 'Unable to create file %s', patFileName)
    fwrite(fid, Data_to_write(:),'uchar');
    stat = stat + fclose(fid);
    
    % position function associated with the pattern
    
    posFuncFreqs = keys(pattern.freqVecMap);
    
    behavExpStruct(ii).posFuncNums = zeros(1, pattern.freqVecMap.Count);
    statPF = 0;
    for jj=1:length(posFuncFreqs)
        func = pattern.freqVecMap(posFuncFreqs{jj});
        
        Header_blockFunc(1:4) = dec2char(length(func)*2, 4);     %each function datum is stored in two bytes in the SD card
        fileName = ['position_stim_', num2str(jj)]; 
        Header_blockFunc(5) = length(fileName);
        Header_blockFunc(6: 6 + length(fileName) -1) = fileName;
        
        pos_func_counter = pos_func_counter + 1;
        behavExpStruct(ii).posFuncNums(jj) = pos_func_counter;
        
        padsF = repmat('0', 1, 4-length(pos_func_counter));
        funcFileName = ['pos', padsF, num2str(pos_func_counter) '.fun'];
        
        function_Data = signed_16Bit_to_char(func);     
    
        
        Data_to_writeFunc = [Header_blockFunc function_Data]; 
        fidFunc = fopen([temp_pathFunc '\' funcFileName] , 'w');
        assert(fidFunc ~= -1, 'Unable to create file %s', funcFileName)
        fwrite(fidFunc, Data_to_writeFunc(:),'uchar');
        statPF = statPF + fclose(fidFunc); % if fine should stay zero
    end
    
    assert(statPF == 0, 'Failed to create position functions to Pattern %d', ii)
    fprintf('%d function files written to Function folder (out of %d) \n', jj, length(posFuncFreqs))

end

assert(stat == 0, 'Failed to create pattern files')
fprintf('%d pattern files written to Pattern folder (out of %d) \n', ii, length(dirSt))






end