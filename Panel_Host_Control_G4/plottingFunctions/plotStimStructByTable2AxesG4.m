function varargout = plotStimStructByTable2AxesG4(pStruct, figName, axeNames, colName, plotParSt)

% function varargout = plotStimStructByTable2AxesG4(pStruct, figDim, posDim, colDim, plotSt)
%
% This function is a modification of plotStimStructByTable. instead of using
% relInds/combInds it uses gratingTable with a combination of maskPos and maskOrt. 
% This functions plots the data in pStruct based on the separation in the
% different dimensions. pStruct should have a .stim field, and should work
% with getStimInds (have either a relInds or a combInds field). 
% 
% INPUTS
% pStruct -         protocol structure with .stim field and .data in it
% figName -         String. Dimension accorind to which data would be seperated
%                   into different figures (names are var names from gratingTable).
% axeName -         cell array with rowName and ColName in it. For each figure rows and columns will be determined
% colName -         same as above only to different colors within axes. 
%
% plotParSt -       (optional) structure with different parameters that
%                   will affect data plotting 
% .rmSpikes -       logical. if true median filters the voltage trace
% .rmSpkWin -       integer. Window size for smoothSpikes median filter (in samples).
%                   Defualt 101
% .figPar -         fields within .figPar will be applied on each figure.
%                   if only one is given same paraemters will be applied on
%                   all figures generated. 
%                   figPar can contain the following fields:
%   .axesNum -      2 element vector to describe number of axes to plot on
%                   the X and Y dimensitons of each figure. default is
%                   [floor(sqrt(numAxesDim)), ceil(sqrt(numAxesDim))]
%   .axesOrd -      1XnumAxes vector describing the order in which axes are
%                   to be populated. Default is 1:numAxes
%   .cols -         2*numColDimX3 colors to be used in plotting the data
%                   for the figure. default pallete is cbrewer(Paired), to
%                   match mean and individual repeats. If input is just
%                   numColDimX3 mean and indiv are at the same color
%   .plotMeanOrReps - flag for plotting mean, repeats, or both 
%                     0 - repeats only (default)
%                     1 - mean only
%                     2 - both
%
% if figPar is left empty for a particular figure it will be generated by
% default parameters.
%
% fig/axe/colName can also be none if it not needed


%% verifying input correctness

close all


assert(isfield(pStruct, 'stim'), 'pStrcut is missing stim field')
%assert(isfield(pStruct.stim, 'data'), 'stim is missing data field')
assert(isfield(pStruct, 'gratingTable'), 'stim is missing gratingTable field')

stimInds = vertcat(pStruct.stim.relInds);
relTable = pStruct.gratingTable;
relTable.none = ones(height(relTable),1);
colTableNames = relTable.Properties.VariableNames;

acceptNames =  [colTableNames, {'maskPos', 'maskOrt'}];
acpNameStr = cellfun(@(x) [x, ' '], acceptNames, 'uniformoutput', 0);
acpNameStr = [acpNameStr{:}];

assert(iscell(axeNames), 'axesNames should be a 1X2 cell array')
assert(all(size(axeNames) == [1,2]), 'axesNames should be a 1X2 cell array')

if ~all(ismember([{figName}, axeNames, {colName}], acceptNames)) %to add maskPos as an option
    fprintf('relevant variable names are: \n')
    cellfun(@(x) fprintf('%s \t', x), colTableNames)
    fprintf('\n');
    error('Given name does not match variable names in table \nAcceptable names are: %s', acpNameStr)
end

assert(ismember('index', colTableNames), 'gratingTable is missing index variable')

maskPosI=0;
maskOrtI=0;
if strcmp(figName, 'maskPos')
    figIndVals = unique(stimInds(:,4));
    maskPosI=1;
elseif strcmp(figName, 'maskOrt')
    figIndVals = unique(stimInds(:,3));
    maskOrtI=1;
else
    figIndVals = unique(relTable{:, figName});
end

numFigs = length(figIndVals);


for ff=1:numFigs
    
    if ismember(figName, {'maskPos', 'maskOrt'})
        tempTab = relTable;
    else
        tempTab = relTable(relTable{:, figName} == figIndVals(ff), :);
    end
    
    axeIndValsCell = cell(1,2);
    for ii=1:2
        if strcmp(axeNames{ii}, 'maskPos')
            axeIndValsCell{ii} = unique(stimInds(:,4));
            maskPosI=2 + 0.1*ii;
        elseif strcmp(axeNames{ii}, 'maskOrt')
            axeIndValsCell{ii} = unique(stimInds(:,3));
            maskOrtI=2 + 0.1*ii;   
        else
            axeIndValsCell{ii} = unique(tempTab{:, axeNames{ii}});
        end
    end

    axeRowIndVals = axeIndValsCell{1};
    axeColIndVals = axeIndValsCell{2};
    
    if strcmp(colName, 'maskPos')
        colIndVals = unique(stimInds(:,4));
        maskPosI=3;
	elseif strcmp(colName, 'maskOrt')
        colIndVals = unique(stimInds(:,3));
        maskOrtI=3;
    else
        colIndVals = unique(tempTab{:, colName});
    end
    
    plotSt.figPar(ff).relAxeRowVal = axeRowIndVals;
    plotSt.figPar(ff).relAxeColVal = axeColIndVals;
    plotSt.figPar(ff).relColVal = colIndVals;
    plotSt.figPar(ff).relNumAxeRow = length(axeRowIndVals);
    plotSt.figPar(ff).relNumAxeCol = length(axeColIndVals);
    plotSt.figPar(ff).relNumCol = length(colIndVals);
    plotSt.figPar(ff).axesNum = [length(axeColIndVals), length(axeRowIndVals)];
    plotSt.figPar(ff).axesOrd = 1:prod(plotSt.figPar(ff).axesNum);
    plotSt.figPar(ff).cols = cbrewer('qual', 'Paired', 2*max(plotSt.figPar(ff).relNumCol,3)); % so that it wont report a warning
    plotSt.figPar(ff).plotMeanOrReps = 1;
end


%% managing the plotParSt input

rmSpF = 0;
rmSpW = 101;

if nargin == 5
    
    if isfield(plotParSt, 'rmSpikes')
        rmSpF = plotParSt.rmSpikes;
    end
    
    if isfield(plotParSt, 'rmSpkWin')
        rmSpW = plotParSt.rmSpkWin;
    end
    
    
    % if input structure has length one, apply parameters on all figures
    if length(plotParSt.figPar) == 1 && numFigs > 1
        for ff=2:numFigs
            plotParSt.figPar(ff) = plotParSt.figPar(1);
        end
    end
    
    for ff=1:numFigs
        if isfield(plotParSt.figPar, 'axesNum')
            if ~isempty(plotParSt.figPar(ff).axesNum)
                tempAxeNum = plotParSt.figPar(ff).axesNum;
                assert(length(tempAxeNum) == 2, 'axesNum input for fig %d has wrong dimension', ff)
                assert(prod(tempAxeNum) >= plotSt.figPar(ff).relNumAxeRow * plotSt.figPar(ff).relNumAxeCol, 'axesNum for fig %d is too small', ff)
                plotSt.figPar(ff).axesNum = tempAxeNum;
            end
        end
        
        if isfield(plotParSt.figPar, 'axesOrd')
            if ~isempty(plotParSt.figPar(ff).axesOrd)
                tempAxeOrd = plotParSt.figPar(ff).axesOrd;
                assert(length(tempAxeOrd) == plotSt.figPar(ff).relNumAxeRow * plotSt.figPar(ff).relNumAxeCol, ... 
                       'axes order for fig %d is not equal to number of axes', ff) % assumes the matrix of rowXcol is full - maybe change
                plotSt.figPar(ff).axesOrd = tempAxeOrd;
            end
        end
        
        if isfield(plotParSt.figPar, 'cols')
            if ~isempty(plotParSt.figPar(ff).cols)
                tempCols = plotParSt.figPar(ff).cols;
                assert(size(tempCols, 2) == 3, 'Color input should be a 3 element vector')
                assert(size(tempCols, 1) >= plotSt.figPar(ff).relNumCol, 'Colors in fig %d exceed colors inputs', ff)
                plotSt.figPar(ff).cols = tempCols;
            end
        end
        
        if isfield(plotParSt.figPar, 'plotMeanOrReps')
            if ~isempty(plotParSt.figPar(ff).plotMeanOrReps)
                tempRepsFlag = plotParSt.figPar(ff).plotMeanOrReps;
                assert(ismember(tempRepsFlag, [0,1,2]), 'plotMeanOrReps should be 0,1, or 2 ')
                plotSt.figPar(ff).plotMeanOrReps = tempRepsFlag;
            end
        end
    end
end
   
%% plotting the data

maxTime = 0;

for ff=1:numFigs
    
    handles.fig(ff).figH = figure;
    relAxe = plotSt.figPar(ff).axesNum;
    relOrd = plotSt.figPar(ff).axesOrd;
    relCol = plotSt.figPar(ff).cols;
    posCell = generatePositionCell(0.05, 0.975, 0.025, 0.95, 0.01, 0.01, relAxe);
    
    posInd=1;
    ortInd=1;
    
    if maskPosI ==1
        posInd = figIndVals(ff);
        tempFigInd = ones(height(relTable), 1);
    elseif maskOrtI ==1
        ortInd = figIndVals(ff);
        tempFigInd = ones(height(relTable), 1);
    else
        tempFigInd = relTable{:, figName} == figIndVals(ff);
    end
    
    axeCount = 0;
    for ii=1:plotSt.figPar(ff).relNumAxeRow
        
        if maskPosI == 2.1
            posInd = plotSt.figPar(ff).relAxeRowVal(ii);
            tempAxeRowInd = ones(height(relTable), 1);
        elseif maskOrtI == 2.1
            ortInd = plotSt.figPar(ff).relAxeRowVal(ii);
            tempAxeRowInd = ones(height(relTable), 1);
        else
            tempAxeRowInd = relTable{:, axeNames{1}} == plotSt.figPar(ff).relAxeRowVal(ii);
        end
        
        tempAxeRowVal = plotSt.figPar(ff).relAxeRowVal(ii);
        
        for jj=1:plotSt.figPar(ff).relNumAxeCol
            
            axeCount= axeCount+1;
            
            if maskPosI == 2.2
                posInd = plotSt.figPar(ff).relAxeColVal(jj);
                tempAxeColInd = ones(height(relTable), 1);
            elseif maskOrtI == 2.2
                ortInd = plotSt.figPar(ff).relAxeColVal(jj);
                tempAxeColInd = ones(height(relTable), 1);
            else
                tempAxeColInd = relTable{:, axeNames{2}} == plotSt.figPar(ff).relAxeColVal(jj);
            end

            tempAxeColVal = plotSt.figPar(ff).relAxeColVal(jj);
            
            handles.fig(ff).axh(ii,jj) = axes('position', posCell{relOrd(axeCount)});
            hold on
        
            if 2*plotSt.figPar(ff).relNumCol == size(plotSt.figPar(ff).cols, 1)
                indvColInd = 1:2:2*plotSt.figPar(ff).relNumCol;
                meanColInd = 2:2:2*plotSt.figPar(ff).relNumCol;
            else
                indvColInd = 1:plotSt.figPar(ff).relNumCol;
                meanColInd = 1:plotSt.figPar(ff).relNumCol;
            end
        
            for kk=1:plotSt.figPar(ff).relNumCol
                
                if maskPosI == 3
                    posInd = plotSt.figPar(ff).relColVal(kk);
                    tempColInd = ones(height(relTable), 1);
                elseif maskOrtI == 3
                    ortInd = plotSt.figPar(ff).relColVal(kk);
                    tempColInd = ones(height(relTable), 1);
                else
                    tempColInd = relTable{:, colName} == plotSt.figPar(ff).relColVal(kk);
                end
            
                rowInd = prod([tempFigInd, tempAxeRowInd, tempAxeColInd, tempColInd], 2);
                gratInd = relTable{logical(rowInd), 'index'};
                
                if isempty(gratInd)
                    continue
                end
                
                assert(length(gratInd) == 1, 'variable names combination does not provide unique identity in gratingTable')
            
                plotIndsSt = getStimInds(pStruct, [gratInd, nan, ortInd, posInd]);
                plotInds = [plotIndsSt(:).inds];
                [datToPlot, timeToPlot] = getStimDataByInds(pStruct, plotInds);
                
                if rmSpF == 1
                    datToPlot = smoothSpikes(datToPlot, rmSpW);
                end
            
                % with the way color are processed here it will not work with
                % regular color input
                
                notNanInds = all(~isnan(timeToPlot), 2);
                meanTime = mean(timeToPlot(notNanInds, :),2);
                
                switch plotSt.figPar(ff).plotMeanOrReps
                    case 0 
                        plot(timeToPlot, datToPlot, 'lineWidth', 1, 'color', relCol(indvColInd(kk), :))
                    case 1

                        plot(meanTime, mean(datToPlot(notNanInds, :),2), 'lineWidth', 2, 'color', relCol(meanColInd(kk), :))
                    case 2
                        plot(timeToPlot, datToPlot, 'lineWidth', 1, 'color', relCol(indvColInd(kk), :))

                        plot(meanTime, mean(datToPlot(notNanInds, :),2), 'lineWidth', 3, 'color', relCol(meanColInd(kk), :))
                end
                
                if ii==1
                    title(num2str(tempAxeColVal))
                end
                
                if jj==1
                    ylabel(num2str(tempAxeRowVal))
                end
                
                if meanTime(end) > maxTime
                    maxTime =  meanTime(end);
                end
            end
            
        end
        
    end
    
end


allY = [];
for ff=1:numFigs
    allY = vertcat(allY, handles.fig(ff).axh(:).YLim);
end

totYLim = [min(allY(:,1)), max(allY(:,2))];

for ff=1:numFigs
    for ii=1:size(handles.fig(ff).axh, 1)
        for jj=1:size(handles.fig(ff).axh, 2)
            handles.fig(ff).axh(ii,jj).YLim = totYLim;
            handles.fig(ff).axh(ii,jj).XLim = [0, maxTime];
        end
    end
    
    midRow = ceil(ii/2);
    midCol = ceil(jj/2);
%     xxTick = handles.fig(ff).axh(1,1).XTick;
%     yyTick = handles.fig(ff).axh(1,1).YTick;
%     xxTickLab = handles.fig(ff).axh(1,1).XTickLabel;
%     yyTickLab = handles.fig(ff).axh(1,1).YTickLabel;
    
    set(handles.fig(ff).axh(:, 2:end), 'YTickLabel', [])
    set(handles.fig(ff).axh(1:end-1, :), 'XTickLabel', [])
    
    tempYLab = handles.fig(ff).axh(midRow, 1).YLabel.String;
    handles.fig(ff).axh(midRow, 1).YLabel.String = {axeNames{1}; tempYLab};
    
    tempXTit = handles.fig(ff).axh(1, midCol).Title.String;
    handles.fig(ff).axh(1, midCol).Title.String = {axeNames{2}; tempXTit};
    
end

        
if nargout == 1
    varargout{1} = handles;
end
    

end
