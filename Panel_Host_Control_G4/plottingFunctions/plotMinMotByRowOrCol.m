function plotMinMotByRowOrCol(minMotSt, inputVec)

% function plotMinMotReduced(minMotSt, inputVec)
%
% the function plots the minMot data with more direct comparisons of means.
% Data can be plotted either as per column, or per row. 
% function uses stimDur to shift data so it aligns with the apperance of
% the second bar
%
% INPUT
%
% minMOtSt -        structure generated by calcMinMotMeans with .mean field
%                   in it, and data organized by bar position and timing
% inputVec -        1X2 vector specifying which input is desired. first position
%                   is related to first bar position, second to second bar
%                   position.
%   1)  To plot a column give the desired first bar position in the first
%       and NaN in the second
%   2)  To plot a row give the desired second bar position in the second and NaN in the first 
%   3) to plot the diagonal enter nan in both positions
%  
%
% Timing is plotted as pairwise comparisons and the plot is always shifted
% so that the second bar appearance is aligned. 
%
% examples:
% 1) [0, NaN]  will plot all the stim that had the first bar at zero
% 
%
% Note!! function assumes only one uniStim (BB usually)
%


timeTit = {'Simultaneous'; 'First bar disappears'; 'First bar remains'};

assert(isvector(inputVec), 'inputVec should be a 1X2 vector')
assert(length(inputVec) == 2, 'inputVec should be a 1X2 vector')

assert(isfield(minMotSt(1), 'data'), 'minMotSt is missing data field')
assert(isfield(minMotSt(1).data, 'mean'), 'minMotSt is missing mean field')

stimDur = minMotSt.stimDur;
datSiz = size(minMotSt(1).data);
relTimeTit = timeTit(end-datSiz(3)+1:end);

convInpV = inputVec + ceil(datSiz(1)/2); % since center is zero position and it is always an odd number of positions

firstBarInd = convInpV(1);
secondBarInd = convInpV(2);

if ~isnan(firstBarInd)
    assert(sum(ismember(firstBarInd, 1:datSiz(1))) ==1, 'first index out of range')
    fNan = 0;
else
    fNan =1;
end

if ~isnan(secondBarInd)
    assert(sum(ismember(secondBarInd, 1:datSiz(1))) ==1, 'second index out of range')
    sNan = 0;
else
    sNan = 1;
end

diagFlag = 0;
% selecting relevant data
if ~fNan && sNan
    relData = squeeze(minMotSt(1).data(firstBarInd, :, :));
    relZeroInd = firstBarInd;
    
elseif fNan && ~sNan
    relData = squeeze(minMotSt(1).data(:, secondBarInd, :));
    relZeroInd = secondBarInd;
elseif fNan && sNan
    for ii=1:datSiz(1)
        relData(ii, :) = squeeze(minMotSt(1).data(ii, ii, :));
        relZeroInd = ceil(datSiz(1)/2);
        diagFlag = 1;
    end
elseif ~fNan && ~sNan
    error('use plotMinMotReciprocalPositions instead')
end

%plotting the data

midPosCol = [1,1,1]*0.65;

fh = figure('units', 'normalized', 'position', [0.12, 0.12, 0.2, 0.7], 'name', num2str(inputVec));

axh = zeros(1, datSiz(3)-diagFlag);
posCell = generatePositionCell(0.05, 0.975, 0.025, 0.95, -1, 0.05, datSiz(3)-diagFlag);


%relCol = cbrewer('qual', 'Paired', 2*max(datSiz(1) - relZeroInd, relZeroInd));
relCol = cbrewer('qual', 'Set1', max(datSiz(1) - relZeroInd, relZeroInd));
skipFac = 500;

for tt=1:datSiz(3)-diagFlag
    axh(tt)  = axes('position', posCell{tt});
    title(relTimeTit{tt})
    hold on
    for ii=1:datSiz(1)
            
        tempFac = abs(ii-relZeroInd) * stimDur * ~diagFlag;
        barDiff = relZeroInd - ii;
        if barDiff == 0 && ~isempty(relData(ii, tt).mean)
            tempH = plot(relData(ii, tt).mean(:,1) - tempFac, relData(ii, tt).mean(:,2), 'color', midPosCol, 'linewidth', 2); 
        elseif barDiff > 0 && ~isempty(relData(ii, tt).mean)
            tempH = plot(relData(ii, tt).mean(:,1) - tempFac, relData(ii, tt).mean(:,2), 'color', relCol(abs(barDiff), :), 'linewidth', 2);
        elseif barDiff < 0 && ~isempty(relData(ii, tt).mean)
            plot(relData(ii, tt).mean(:,1) - tempFac, relData(ii, tt).mean(:,2), ...
                'color', relCol(abs(barDiff), :), 'linewidth', 2)
            tempH = plot(relData(ii, tt).mean(1:skipFac:end,1) - tempFac, relData(ii, tt).mean(1:skipFac:end,2), ...
                         'o', 'color', relCol(abs(barDiff), :), 'markersize', 6, 'markerfacecolor', relCol(abs(barDiff), :));
        end
            
        if tt==1
            set(tempH, 'Tag', 'legFlag');
        end
            
    end
        
    hold off 
end

hForLeg = flipud(findobj(axh(1), 'Tag', 'legFlag')); %since it is reversed when found
numForLeg = (1:datSiz(1)) - relZeroInd;

if floor(datSiz(1)/2) == datSiz(1)/2
    numForLeg(numForLeg <= 0) = numForLeg(numForLeg <= 0)-1; % since if it is even the sim case is not presented
end

legStr = arrayfun(@(x) ['barDiff:', num2str(x)], numForLeg, 'uniformoutput', 0); 

legend(axh(1), hForLeg, legStr, 'location', 'best')

             
yyLim = get(axh(:), 'YLim');
if iscell(yyLim)
    yyLim = vertcat(yyLim{:});
end
yyMax = max(yyLim(:,2));
yyMin = min(yyLim(:,1));

xxLim = [-200, 400];

set(axh(:), 'YLim', [yyMin, yyMax], 'XLim', xxLim)




end
