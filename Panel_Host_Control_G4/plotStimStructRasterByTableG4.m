function varargout = plotStimStructRasterByTableG4(pStruct, figName, axeName, colName, plotParSt)

% function varargout = plotStimStructRasterByTableG4(pStruct, figDim, posDim, colDim, plotSt)
%
% This function is a modification of plotStimStructByTable. It uses both
% relInds/combInds and gratingTable. 
%
% maskPos and maskOrt can be used to refer to positions 3 and 4 in relInds
% The other 2 positions are referred through the gratingTable
%
% This functions plots the data in pStruct based on the separation in the
% different dimensions. pStruct should have a .stim field, and should work
% with getStimInds (have either a relInds or a combInds field). 
% 
% INPUTS
% pStruct -         protocol structure with .stim field and .data in it
% figName -         String. Dimension accorind to which data would be seperated
%                   into different figures (names are var names from gratingTable).
% axeName -         same as above only to different axes within figure.
% colName -         same as above only to different colors within axes. 
%
% Note! in this version 'maskPos' is also a valid entry even it is not in the
% table since it will use maskPositions
%
% plotParSt -       (optional) structure with different parameters that
%                   will affect data plotting 
% .figPar -         fields within .figPar will be applied on each figure.
%                   if only one is given same paraemters will be applied on
%                   all figures generated. 
%                   figPar can contain the following fields:
%   .axesNum -      2 element vector to describe number of axes to plot on
%                   the X and Y dimensitons of each figure. default is
%                   [floor(sqrt(numAxesDim)), ceil(sqrt(numAxesDim))]
%   .axesOrd -      1XnumAxes vector describing the order in which axes are
%                   to be populated. Default is 1:numAxes
%   .cols -         2*numColDimX3 colors to be used in plotting the data
%                   for the figure. default pallete is cbrewer(Paired), to
%                   match mean and individual repeats. If input is just
%                   numColDimX3 mean and indiv are at the same color
%
% if figPar is left empty for a particular figure it will be generated by
% default parameters.
%
% fig/axe/colName can also be none if it not needed



%% verifying input correctness

% close all


assert(isfield(pStruct, 'stim'), 'pStrcut is missing stim field')
assert(isfield(pStruct.stim, 'data'), 'stim is missing data field')
assert(isfield(pStruct, 'gratingTable'), 'stim is missing gratingTable field')

relTable = pStruct.gratingTable;
relTable.none = ones(height(relTable),1);
colTableNames = relTable.Properties.VariableNames;

numPos = size(pStruct.maskPositions,1); 
stimInds = vertcat(pStruct.stim.relInds);
acceptNames =  [colTableNames, {'maskPos', 'maskOrt'}];
acpNameStr = cellfun(@(x) [x, ' '], acceptNames, 'uniformoutput', 0);
acpNameStr = [acpNameStr{:}];
if ~all(ismember({figName, axeName, colName},acceptNames)) %to add maskPos as an option
    fprintf('relevant variable names are: \n')
    cellfun(@(x) fprintf('%s \t', x), colTableNames)
    fprintf('\n');
    error('Given name does not match variable names in table. \nAcceptable names are: %s', acpNameStr)
end
assert(ismember('index', colTableNames), 'gratingTable is missing index variable')

maskOrtI=0;
maskPosI=0;
if strcmp(figName, 'maskPos')
    figIndVals = unique(stimInds(:,4));
    maskPosI=1;
elseif strcmp(figName, 'maskOrt')
    figIndVals = unique(stimInds(:,3));
    maskOrtI=1;
else
    figIndVals = unique(relTable{:, figName});
end
numFigs = length(figIndVals);

% to be used if maskPosI is 2
xMaskPos = length(unique(pStruct.maskPositions(:,1)));
yMaskPos = length(unique(pStruct.maskPositions(:,2)));


for ii=1:numFigs
    
    if ismember(figName, {'maskPos', 'maskOrt'})
        tempTab = relTable;
    else
        tempTab = relTable(relTable{:, figName} == figIndVals(ii), :);
    end
    
    if strcmp(axeName, 'maskPos')
        axeIndVals = unique(stimInds(:,4));
        maskPosI=2;   
    elseif strcmp(axeName, 'maskOrt')
        axeIndVals = unique(stimInds(:,3));
        maskOrtI=2;   
    else
        axeIndVals = unique(tempTab{:, axeName});
    end
    
    if strcmp(colName, 'maskPos')
        colIndVals = unique(stimInds(:,4));
        maskPosI=3;
    elseif strcmp(colName, 'maskOrt')
        colIndVals = unique(stimInds(:,3));
        maskOrtI=3;
    else
        colIndVals = unique(tempTab{:, colName});
    end
    
    plotSt.figPar(ii).relAxeVal = axeIndVals;
    plotSt.figPar(ii).relColVal = colIndVals;
    plotSt.figPar(ii).relNumAxe = length(axeIndVals);
    plotSt.figPar(ii).relNumCol = length(colIndVals);
    if maskPosI == 2
        plotSt.figPar(ii).axesNum = [xMaskPos, yMaskPos];
        rotPos = 1;
    else
        plotSt.figPar(ii).axesNum = [ceil(sqrt(plotSt.figPar(ii).relNumAxe)), ceil(sqrt(plotSt.figPar(ii).relNumAxe))];
        rotPos = 0;
    end
    plotSt.figPar(ii).axesOrd = 1:length(axeIndVals);
    if plotSt.figPar(ii).relNumCol < 9 % since set1 has 9 clean colors
        plotSt.figPar(ii).cols = cbrewer('qual', 'Dark2', plotSt.figPar(ii).relNumCol); 
    else
        baseCols = cbrewer('qual', 'Dark2', 8); 
        repCol = ceil(plotSt.figPar(ii).relNumCol/8);
        plotSt.figPar(ii).cols = repmat(baseCols, repCol, 1);
    end
end




%% managing the plotParSt input
if nargin == 5
    assert(isfield(plotParSt, 'figPar'), 'plotParSt is missing figPar field')
    
    % if input structure has length one, apply parameters on all figures
    if length(plotParSt.figPar) == 1 && numFigs > 1
        for ii=2:numFigs
            plotParSt.figPar(ii) = plotParSt.figPar(1);
        end
    end
    
    for ii=1:numFigs
        if isfield(plotParSt.figPar, 'axesNum')
            if ~isempty(plotParSt.figPar(ii).axesNum)
                tempAxeNum = plotParSt.figPar(ii).axesNum;
                assert(length(tempAxeNum) == 2, 'axesNum input for fig %d has wrong dimension', ii)
                assert(prod(tempAxeNum) >= plotSt.figPar(ii).relNumAxe, 'axesNum for fig %d is too small', ii)
                plotSt.figPar(ii).axesNum = tempAxeNum;
            end
        end
        
        if isfield(plotParSt.figPar, 'axesOrd')
            if ~isempty(plotParSt.figPar(ii).axesOrd)
                tempAxeOrd = plotParSt.figPar(ii).axesOrd;
                assert(length(tempAxeOrd) == plotSt.figPar(ii).relNumAxe, ...
                       'axes order for fig %d os not equal to number of axes', ii)
                plotSt.figPar(ii).axesOrd = tempAxeOrd;
            end
        end
        
        if isfield(plotParSt.figPar, 'cols')
            if ~isempty(plotParSt.figPar(ii).cols)
                tempCols = plotParSt.figPar(ii).cols;
                assert(size(tempCols, 2) == 3, 'Color input should be a 3 element vector')
                assert(size(tempCols, 1) >= plotSt.figPar(ii).relNumCol, 'Colors in fig %d exceed colors inputs', ii)
                plotSt.figPar(ii).cols = tempCols;
            end
        end
        
    end
end
   
%% plotting the data

maxTime = 0;

for ii=1:numFigs
    
    handles.fig(ii).figH = figure;
    
    relAxe = plotSt.figPar(ii).axesNum;
    relOrd = plotSt.figPar(ii).axesOrd;
    relCol = plotSt.figPar(ii).cols;
    posCell = generatePositionCell(0.05, 0.975, 0.025, 0.95, 0.02, 0.02, relAxe);
    if rotPos
        posCell = rot90(posCell);
    end
    
    posInd=1;
    ortInd=1;
    if maskPosI ==1
        posInd = figIndVals(ii);
        tempFigInd = ones(height(relTable), 1);
    elseif maskOrtI ==1
        ortInd = figIndVals(ii);
        tempFigInd = ones(height(relTable), 1);
    else
        tempFigInd = relTable{:, figName} == figIndVals(ii);
    end
    
    
    for jj=1:plotSt.figPar(ii).relNumAxe
        
        if maskPosI == 2
            posInd = plotSt.figPar(ii).relAxeVal(jj);
            tempAxeInd = ones(height(relTable), 1);
        elseif maskOrtI == 2
            ortInd = plotSt.figPar(ii).relAxeVal(jj);
            tempAxeInd = ones(height(relTable), 1);
        else
            tempAxeInd = relTable{:, axeName} == plotSt.figPar(ii).relAxeVal(jj);
        end
        
        handles.fig(ii).axh(jj) = axes('position', posCell{relOrd(jj)});
        hold on
        yCount = -0.5;
        
        if 2*plotSt.figPar(ii).relNumCol == size(plotSt.figPar(ii).cols, 1)
%             indvColInd = 1:2:2*plotSt.figPar(ii).relNumCol;
            meanColInd = 2:2:2*plotSt.figPar(ii).relNumCol;
        else
%             indvColInd = 1:plotSt.figPar(ii).relNumCol;
            meanColInd = 1:plotSt.figPar(ii).relNumCol;
        end
        
        for kk=1:plotSt.figPar(ii).relNumCol
            
            if maskPosI == 3
                posInd = plotSt.figPar(ii).relColVal(kk);
                tempColInd = ones(height(relTable), 1);
            elseif maskOrtI == 3
                ortInd = plotSt.figPar(ii).relColVal(kk);
                tempColInd = ones(height(relTable), 1);
            else
                tempColInd = relTable{:, colName} == plotSt.figPar(ii).relColVal(kk);
            end
            
            rowInd = prod([tempFigInd, tempAxeInd, tempColInd], 2);
            gratInd = relTable{logical(rowInd), 'index'};
            assert(length(gratInd) == 1, 'variable names combination does not provide unique identity in gratingTable')
            
            plotIndsSt = getStimInds(pStruct, [gratInd, nan, ortInd, posInd]);
            plotInds = [plotIndsSt(:).inds];
            [datToPlot, timeToPlot] = getStimDataByInds(pStruct, plotInds);
            
            % with the way color are processed here it will not work with
            % regular color input
            
            for rr=1:size(datToPlot,2)
                yCount = yCount+1;
                relD = datToPlot(:,rr); 
                plotRasterCrude(timeToPlot, relD, yCount, relCol(meanColInd(kk), :))
            end
            
            notNanInds = all(~isnan(timeToPlot), 2);
            meanTime = mean(timeToPlot(notNanInds, :),2);
           
            
            if maskPosI==2
                title(num2str(pStruct.maskPositions(jj,:)))
            else
                title(num2str(jj))
            end
            
            if meanTime(end) > maxTime
                maxTime =  meanTime(end);
            end
            
        end
        
         handles.fig(ii).yCount(jj) = yCount;
        
    end
    
end


for ii=1:numFigs
    for jj=1:length(handles.fig(ii).axh)
        handles.fig(ii).axh(jj).YLim = [0.5, handles.fig(ii).yCount(jj)+1];
        handles.fig(ii).axh(jj).XLim = [0, maxTime];
    end
end
        
if nargout == 1
    varargout{1} = handles;
end
    

end
